// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/game"
)

// File is the model entity for the File schema.
type File struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Path holds the value of the "path" field.
	Path string `json:"path,omitempty"`
	// OriginalName holds the value of the "original_name" field.
	OriginalName string `json:"original_name,omitempty"`
	// NormalizedName holds the value of the "normalized_name" field.
	NormalizedName string `json:"normalized_name,omitempty"`
	// SetKey holds the value of the "set_key" field.
	SetKey string `json:"set_key,omitempty"`
	// Checksum holds the value of the "checksum" field.
	Checksum string `json:"checksum,omitempty"`
	// SizeBytes holds the value of the "size_bytes" field.
	SizeBytes int64 `json:"size_bytes,omitempty"`
	// MimeType holds the value of the "mime_type" field.
	MimeType string `json:"mime_type,omitempty"`
	// Format holds the value of the "format" field.
	Format string `json:"format,omitempty"`
	// Source holds the value of the "source" field.
	Source string `json:"source,omitempty"`
	// Quarantine holds the value of the "quarantine" field.
	Quarantine bool `json:"quarantine,omitempty"`
	// NeedsReview holds the value of the "needs_review" field.
	NeedsReview bool `json:"needs_review,omitempty"`
	// DiskNumber holds the value of the "disk_number" field.
	DiskNumber *int `json:"disk_number,omitempty"`
	// Side holds the value of the "side" field.
	Side string `json:"side,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the FileQuery when eager-loading is set.
	Edges        FileEdges `json:"edges"`
	game_files   *string
	selectValues sql.SelectValues
}

// FileEdges holds the relations/edges for other nodes in the graph.
type FileEdges struct {
	// Game holds the value of the game edge.
	Game *Game `json:"game,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
	// totalCount holds the count of the edges above.
	totalCount [1]map[string]int
}

// GameOrErr returns the Game value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e FileEdges) GameOrErr() (*Game, error) {
	if e.Game != nil {
		return e.Game, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: game.Label}
	}
	return nil, &NotLoadedError{edge: "game"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*File) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case file.FieldQuarantine, file.FieldNeedsReview:
			values[i] = new(sql.NullBool)
		case file.FieldSizeBytes, file.FieldDiskNumber:
			values[i] = new(sql.NullInt64)
		case file.FieldID, file.FieldPath, file.FieldOriginalName, file.FieldNormalizedName, file.FieldSetKey, file.FieldChecksum, file.FieldMimeType, file.FieldFormat, file.FieldSource, file.FieldSide:
			values[i] = new(sql.NullString)
		case file.ForeignKeys[0]: // game_files
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the File fields.
func (f *File) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case file.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				f.ID = value.String
			}
		case file.FieldPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field path", values[i])
			} else if value.Valid {
				f.Path = value.String
			}
		case file.FieldOriginalName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field original_name", values[i])
			} else if value.Valid {
				f.OriginalName = value.String
			}
		case file.FieldNormalizedName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field normalized_name", values[i])
			} else if value.Valid {
				f.NormalizedName = value.String
			}
		case file.FieldSetKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field set_key", values[i])
			} else if value.Valid {
				f.SetKey = value.String
			}
		case file.FieldChecksum:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field checksum", values[i])
			} else if value.Valid {
				f.Checksum = value.String
			}
		case file.FieldSizeBytes:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field size_bytes", values[i])
			} else if value.Valid {
				f.SizeBytes = value.Int64
			}
		case file.FieldMimeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mime_type", values[i])
			} else if value.Valid {
				f.MimeType = value.String
			}
		case file.FieldFormat:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field format", values[i])
			} else if value.Valid {
				f.Format = value.String
			}
		case file.FieldSource:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source", values[i])
			} else if value.Valid {
				f.Source = value.String
			}
		case file.FieldQuarantine:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field quarantine", values[i])
			} else if value.Valid {
				f.Quarantine = value.Bool
			}
		case file.FieldNeedsReview:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field needs_review", values[i])
			} else if value.Valid {
				f.NeedsReview = value.Bool
			}
		case file.FieldDiskNumber:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field disk_number", values[i])
			} else if value.Valid {
				f.DiskNumber = new(int)
				*f.DiskNumber = int(value.Int64)
			}
		case file.FieldSide:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field side", values[i])
			} else if value.Valid {
				f.Side = value.String
			}
		case file.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field game_files", values[i])
			} else if value.Valid {
				f.game_files = new(string)
				*f.game_files = value.String
			}
		default:
			f.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the File.
// This includes values selected through modifiers, order, etc.
func (f *File) Value(name string) (ent.Value, error) {
	return f.selectValues.Get(name)
}

// QueryGame queries the "game" edge of the File entity.
func (f *File) QueryGame() *GameQuery {
	return NewFileClient(f.config).QueryGame(f)
}

// Update returns a builder for updating this File.
// Note that you need to call File.Unwrap() before calling this method if this File
// was returned from a transaction, and the transaction was committed or rolled back.
func (f *File) Update() *FileUpdateOne {
	return NewFileClient(f.config).UpdateOne(f)
}

// Unwrap unwraps the File entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (f *File) Unwrap() *File {
	_tx, ok := f.config.driver.(*txDriver)
	if !ok {
		panic("ent: File is not a transactional entity")
	}
	f.config.driver = _tx.drv
	return f
}

// String implements the fmt.Stringer.
func (f *File) String() string {
	var builder strings.Builder
	builder.WriteString("File(")
	builder.WriteString(fmt.Sprintf("id=%v, ", f.ID))
	builder.WriteString("path=")
	builder.WriteString(f.Path)
	builder.WriteString(", ")
	builder.WriteString("original_name=")
	builder.WriteString(f.OriginalName)
	builder.WriteString(", ")
	builder.WriteString("normalized_name=")
	builder.WriteString(f.NormalizedName)
	builder.WriteString(", ")
	builder.WriteString("set_key=")
	builder.WriteString(f.SetKey)
	builder.WriteString(", ")
	builder.WriteString("checksum=")
	builder.WriteString(f.Checksum)
	builder.WriteString(", ")
	builder.WriteString("size_bytes=")
	builder.WriteString(fmt.Sprintf("%v", f.SizeBytes))
	builder.WriteString(", ")
	builder.WriteString("mime_type=")
	builder.WriteString(f.MimeType)
	builder.WriteString(", ")
	builder.WriteString("format=")
	builder.WriteString(f.Format)
	builder.WriteString(", ")
	builder.WriteString("source=")
	builder.WriteString(f.Source)
	builder.WriteString(", ")
	builder.WriteString("quarantine=")
	builder.WriteString(fmt.Sprintf("%v", f.Quarantine))
	builder.WriteString(", ")
	builder.WriteString("needs_review=")
	builder.WriteString(fmt.Sprintf("%v", f.NeedsReview))
	builder.WriteString(", ")
	if v := f.DiskNumber; v != nil {
		builder.WriteString("disk_number=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("side=")
	builder.WriteString(f.Side)
	builder.WriteByte(')')
	return builder.String()
}

// Files is a parsable slice of File.
type Files []*File
