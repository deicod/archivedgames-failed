// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/filegroup"
	"github.com/deicod/archivedgames/ent/game"
)

// File is the model entity for the File schema.
type File struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Path holds the value of the "path" field.
	Path string `json:"path,omitempty"`
	// OriginalName holds the value of the "original_name" field.
	OriginalName string `json:"original_name,omitempty"`
	// NormalizedName holds the value of the "normalized_name" field.
	NormalizedName string `json:"normalized_name,omitempty"`
	// SetKey holds the value of the "set_key" field.
	SetKey string `json:"set_key,omitempty"`
	// Checksum holds the value of the "checksum" field.
	Checksum string `json:"checksum,omitempty"`
	// SizeBytes holds the value of the "size_bytes" field.
	SizeBytes int64 `json:"size_bytes,omitempty"`
	// MimeType holds the value of the "mime_type" field.
	MimeType string `json:"mime_type,omitempty"`
	// Format holds the value of the "format" field.
	Format string `json:"format,omitempty"`
	// Source holds the value of the "source" field.
	Source string `json:"source,omitempty"`
	// Quarantine holds the value of the "quarantine" field.
	Quarantine bool `json:"quarantine,omitempty"`
	// NeedsReview holds the value of the "needs_review" field.
	NeedsReview bool `json:"needs_review,omitempty"`
	// DiskNumber holds the value of the "disk_number" field.
	DiskNumber *int `json:"disk_number,omitempty"`
	// Side holds the value of the "side" field.
	Side string `json:"side,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the FileQuery when eager-loading is set.
	Edges            FileEdges `json:"edges"`
	file_group_files *string
	game_files       *string
	selectValues     sql.SelectValues
}

// FileEdges holds the relations/edges for other nodes in the graph.
type FileEdges struct {
	// Game holds the value of the game edge.
	Game *Game `json:"game,omitempty"`
	// Group holds the value of the group edge.
	Group *FileGroup `json:"group,omitempty"`
	// Comments holds the value of the comments edge.
	Comments []*Comment `json:"comments,omitempty"`
	// Reactions holds the value of the reactions edge.
	Reactions []*FileReaction `json:"reactions,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [4]bool
	// totalCount holds the count of the edges above.
	totalCount [4]map[string]int

	namedComments  map[string][]*Comment
	namedReactions map[string][]*FileReaction
}

// GameOrErr returns the Game value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e FileEdges) GameOrErr() (*Game, error) {
	if e.Game != nil {
		return e.Game, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: game.Label}
	}
	return nil, &NotLoadedError{edge: "game"}
}

// GroupOrErr returns the Group value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e FileEdges) GroupOrErr() (*FileGroup, error) {
	if e.Group != nil {
		return e.Group, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: filegroup.Label}
	}
	return nil, &NotLoadedError{edge: "group"}
}

// CommentsOrErr returns the Comments value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) CommentsOrErr() ([]*Comment, error) {
	if e.loadedTypes[2] {
		return e.Comments, nil
	}
	return nil, &NotLoadedError{edge: "comments"}
}

// ReactionsOrErr returns the Reactions value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) ReactionsOrErr() ([]*FileReaction, error) {
	if e.loadedTypes[3] {
		return e.Reactions, nil
	}
	return nil, &NotLoadedError{edge: "reactions"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*File) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case file.FieldQuarantine, file.FieldNeedsReview:
			values[i] = new(sql.NullBool)
		case file.FieldSizeBytes, file.FieldDiskNumber:
			values[i] = new(sql.NullInt64)
		case file.FieldID, file.FieldPath, file.FieldOriginalName, file.FieldNormalizedName, file.FieldSetKey, file.FieldChecksum, file.FieldMimeType, file.FieldFormat, file.FieldSource, file.FieldSide:
			values[i] = new(sql.NullString)
		case file.ForeignKeys[0]: // file_group_files
			values[i] = new(sql.NullString)
		case file.ForeignKeys[1]: // game_files
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the File fields.
func (_m *File) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case file.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case file.FieldPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field path", values[i])
			} else if value.Valid {
				_m.Path = value.String
			}
		case file.FieldOriginalName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field original_name", values[i])
			} else if value.Valid {
				_m.OriginalName = value.String
			}
		case file.FieldNormalizedName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field normalized_name", values[i])
			} else if value.Valid {
				_m.NormalizedName = value.String
			}
		case file.FieldSetKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field set_key", values[i])
			} else if value.Valid {
				_m.SetKey = value.String
			}
		case file.FieldChecksum:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field checksum", values[i])
			} else if value.Valid {
				_m.Checksum = value.String
			}
		case file.FieldSizeBytes:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field size_bytes", values[i])
			} else if value.Valid {
				_m.SizeBytes = value.Int64
			}
		case file.FieldMimeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mime_type", values[i])
			} else if value.Valid {
				_m.MimeType = value.String
			}
		case file.FieldFormat:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field format", values[i])
			} else if value.Valid {
				_m.Format = value.String
			}
		case file.FieldSource:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field source", values[i])
			} else if value.Valid {
				_m.Source = value.String
			}
		case file.FieldQuarantine:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field quarantine", values[i])
			} else if value.Valid {
				_m.Quarantine = value.Bool
			}
		case file.FieldNeedsReview:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field needs_review", values[i])
			} else if value.Valid {
				_m.NeedsReview = value.Bool
			}
		case file.FieldDiskNumber:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field disk_number", values[i])
			} else if value.Valid {
				_m.DiskNumber = new(int)
				*_m.DiskNumber = int(value.Int64)
			}
		case file.FieldSide:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field side", values[i])
			} else if value.Valid {
				_m.Side = value.String
			}
		case file.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_group_files", values[i])
			} else if value.Valid {
				_m.file_group_files = new(string)
				*_m.file_group_files = value.String
			}
		case file.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field game_files", values[i])
			} else if value.Valid {
				_m.game_files = new(string)
				*_m.game_files = value.String
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the File.
// This includes values selected through modifiers, order, etc.
func (_m *File) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryGame queries the "game" edge of the File entity.
func (_m *File) QueryGame() *GameQuery {
	return NewFileClient(_m.config).QueryGame(_m)
}

// QueryGroup queries the "group" edge of the File entity.
func (_m *File) QueryGroup() *FileGroupQuery {
	return NewFileClient(_m.config).QueryGroup(_m)
}

// QueryComments queries the "comments" edge of the File entity.
func (_m *File) QueryComments() *CommentQuery {
	return NewFileClient(_m.config).QueryComments(_m)
}

// QueryReactions queries the "reactions" edge of the File entity.
func (_m *File) QueryReactions() *FileReactionQuery {
	return NewFileClient(_m.config).QueryReactions(_m)
}

// Update returns a builder for updating this File.
// Note that you need to call File.Unwrap() before calling this method if this File
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *File) Update() *FileUpdateOne {
	return NewFileClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the File entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *File) Unwrap() *File {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: File is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *File) String() string {
	var builder strings.Builder
	builder.WriteString("File(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("path=")
	builder.WriteString(_m.Path)
	builder.WriteString(", ")
	builder.WriteString("original_name=")
	builder.WriteString(_m.OriginalName)
	builder.WriteString(", ")
	builder.WriteString("normalized_name=")
	builder.WriteString(_m.NormalizedName)
	builder.WriteString(", ")
	builder.WriteString("set_key=")
	builder.WriteString(_m.SetKey)
	builder.WriteString(", ")
	builder.WriteString("checksum=")
	builder.WriteString(_m.Checksum)
	builder.WriteString(", ")
	builder.WriteString("size_bytes=")
	builder.WriteString(fmt.Sprintf("%v", _m.SizeBytes))
	builder.WriteString(", ")
	builder.WriteString("mime_type=")
	builder.WriteString(_m.MimeType)
	builder.WriteString(", ")
	builder.WriteString("format=")
	builder.WriteString(_m.Format)
	builder.WriteString(", ")
	builder.WriteString("source=")
	builder.WriteString(_m.Source)
	builder.WriteString(", ")
	builder.WriteString("quarantine=")
	builder.WriteString(fmt.Sprintf("%v", _m.Quarantine))
	builder.WriteString(", ")
	builder.WriteString("needs_review=")
	builder.WriteString(fmt.Sprintf("%v", _m.NeedsReview))
	builder.WriteString(", ")
	if v := _m.DiskNumber; v != nil {
		builder.WriteString("disk_number=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("side=")
	builder.WriteString(_m.Side)
	builder.WriteByte(')')
	return builder.String()
}

// NamedComments returns the Comments named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedComments(name string) ([]*Comment, error) {
	if _m.Edges.namedComments == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedComments[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedComments(name string, edges ...*Comment) {
	if _m.Edges.namedComments == nil {
		_m.Edges.namedComments = make(map[string][]*Comment)
	}
	if len(edges) == 0 {
		_m.Edges.namedComments[name] = []*Comment{}
	} else {
		_m.Edges.namedComments[name] = append(_m.Edges.namedComments[name], edges...)
	}
}

// NamedReactions returns the Reactions named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedReactions(name string) ([]*FileReaction, error) {
	if _m.Edges.namedReactions == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedReactions[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedReactions(name string, edges ...*FileReaction) {
	if _m.Edges.namedReactions == nil {
		_m.Edges.namedReactions = make(map[string][]*FileReaction)
	}
	if len(edges) == 0 {
		_m.Edges.namedReactions[name] = []*FileReaction{}
	} else {
		_m.Edges.namedReactions[name] = append(_m.Edges.namedReactions[name], edges...)
	}
}

// Files is a parsable slice of File.
type Files []*File
