// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/deicod/archivedgames/ent/comment"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/filegroup"
	"github.com/deicod/archivedgames/ent/filereaction"
	"github.com/deicod/archivedgames/ent/game"
	"github.com/deicod/archivedgames/ent/gamelike"
	"github.com/deicod/archivedgames/ent/image"
	"github.com/deicod/archivedgames/ent/report"
	"github.com/deicod/archivedgames/ent/sitesetting"
	"github.com/deicod/archivedgames/ent/usershadow"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CommentEdge is the edge representation of Comment.
type CommentEdge struct {
	Node   *Comment `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CommentConnection is the connection containing edges to Comment.
type CommentConnection struct {
	Edges      []*CommentEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CommentConnection) build(nodes []*Comment, pager *commentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Comment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Comment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Comment {
			return nodes[i]
		}
	}
	c.Edges = make([]*CommentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CommentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CommentPaginateOption enables pagination customization.
type CommentPaginateOption func(*commentPager) error

// WithCommentOrder configures pagination ordering.
func WithCommentOrder(order *CommentOrder) CommentPaginateOption {
	if order == nil {
		order = DefaultCommentOrder
	}
	o := *order
	return func(pager *commentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCommentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCommentFilter configures pagination filter.
func WithCommentFilter(filter func(*CommentQuery) (*CommentQuery, error)) CommentPaginateOption {
	return func(pager *commentPager) error {
		if filter == nil {
			return errors.New("CommentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type commentPager struct {
	reverse bool
	order   *CommentOrder
	filter  func(*CommentQuery) (*CommentQuery, error)
}

func newCommentPager(opts []CommentPaginateOption, reverse bool) (*commentPager, error) {
	pager := &commentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCommentOrder
	}
	return pager, nil
}

func (p *commentPager) applyFilter(query *CommentQuery) (*CommentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *commentPager) toCursor(_m *Comment) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *commentPager) applyCursors(query *CommentQuery, after, before *Cursor) (*CommentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCommentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *commentPager) applyOrder(query *CommentQuery) *CommentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCommentOrder.Field {
		query = query.Order(DefaultCommentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *commentPager) orderExpr(query *CommentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCommentOrder.Field {
			b.Comma().Ident(DefaultCommentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Comment.
func (_m *CommentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CommentPaginateOption,
) (*CommentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CommentConnection{Edges: []*CommentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CommentOrderField defines the ordering field of Comment.
type CommentOrderField struct {
	// Value extracts the ordering value from the given Comment.
	Value    func(*Comment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) comment.OrderOption
	toCursor func(*Comment) Cursor
}

// CommentOrder defines the ordering of Comment.
type CommentOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CommentOrderField `json:"field"`
}

// DefaultCommentOrder is the default ordering of Comment.
var DefaultCommentOrder = &CommentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CommentOrderField{
		Value: func(_m *Comment) (ent.Value, error) {
			return _m.ID, nil
		},
		column: comment.FieldID,
		toTerm: comment.ByID,
		toCursor: func(_m *Comment) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Comment into CommentEdge.
func (_m *Comment) ToEdge(order *CommentOrder) *CommentEdge {
	if order == nil {
		order = DefaultCommentOrder
	}
	return &CommentEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   *FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(_m *File) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileOrder.Field {
			b.Comma().Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (_m *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			return _m.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(_m *File) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (_m *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FileGroupEdge is the edge representation of FileGroup.
type FileGroupEdge struct {
	Node   *FileGroup `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// FileGroupConnection is the connection containing edges to FileGroup.
type FileGroupConnection struct {
	Edges      []*FileGroupEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *FileGroupConnection) build(nodes []*FileGroup, pager *filegroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FileGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileGroupPaginateOption enables pagination customization.
type FileGroupPaginateOption func(*filegroupPager) error

// WithFileGroupOrder configures pagination ordering.
func WithFileGroupOrder(order *FileGroupOrder) FileGroupPaginateOption {
	if order == nil {
		order = DefaultFileGroupOrder
	}
	o := *order
	return func(pager *filegroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileGroupFilter configures pagination filter.
func WithFileGroupFilter(filter func(*FileGroupQuery) (*FileGroupQuery, error)) FileGroupPaginateOption {
	return func(pager *filegroupPager) error {
		if filter == nil {
			return errors.New("FileGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filegroupPager struct {
	reverse bool
	order   *FileGroupOrder
	filter  func(*FileGroupQuery) (*FileGroupQuery, error)
}

func newFileGroupPager(opts []FileGroupPaginateOption, reverse bool) (*filegroupPager, error) {
	pager := &filegroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileGroupOrder
	}
	return pager, nil
}

func (p *filegroupPager) applyFilter(query *FileGroupQuery) (*FileGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filegroupPager) toCursor(_m *FileGroup) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *filegroupPager) applyCursors(query *FileGroupQuery, after, before *Cursor) (*FileGroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filegroupPager) applyOrder(query *FileGroupQuery) *FileGroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileGroupOrder.Field {
		query = query.Order(DefaultFileGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filegroupPager) orderExpr(query *FileGroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileGroupOrder.Field {
			b.Comma().Ident(DefaultFileGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileGroup.
func (_m *FileGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileGroupPaginateOption,
) (*FileGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FileGroupConnection{Edges: []*FileGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileGroupOrderField defines the ordering field of FileGroup.
type FileGroupOrderField struct {
	// Value extracts the ordering value from the given FileGroup.
	Value    func(*FileGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filegroup.OrderOption
	toCursor func(*FileGroup) Cursor
}

// FileGroupOrder defines the ordering of FileGroup.
type FileGroupOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *FileGroupOrderField `json:"field"`
}

// DefaultFileGroupOrder is the default ordering of FileGroup.
var DefaultFileGroupOrder = &FileGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileGroupOrderField{
		Value: func(_m *FileGroup) (ent.Value, error) {
			return _m.ID, nil
		},
		column: filegroup.FieldID,
		toTerm: filegroup.ByID,
		toCursor: func(_m *FileGroup) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FileGroup into FileGroupEdge.
func (_m *FileGroup) ToEdge(order *FileGroupOrder) *FileGroupEdge {
	if order == nil {
		order = DefaultFileGroupOrder
	}
	return &FileGroupEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FileReactionEdge is the edge representation of FileReaction.
type FileReactionEdge struct {
	Node   *FileReaction `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// FileReactionConnection is the connection containing edges to FileReaction.
type FileReactionConnection struct {
	Edges      []*FileReactionEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *FileReactionConnection) build(nodes []*FileReaction, pager *filereactionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FileReaction
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileReaction {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileReaction {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileReactionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileReactionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileReactionPaginateOption enables pagination customization.
type FileReactionPaginateOption func(*filereactionPager) error

// WithFileReactionOrder configures pagination ordering.
func WithFileReactionOrder(order *FileReactionOrder) FileReactionPaginateOption {
	if order == nil {
		order = DefaultFileReactionOrder
	}
	o := *order
	return func(pager *filereactionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileReactionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileReactionFilter configures pagination filter.
func WithFileReactionFilter(filter func(*FileReactionQuery) (*FileReactionQuery, error)) FileReactionPaginateOption {
	return func(pager *filereactionPager) error {
		if filter == nil {
			return errors.New("FileReactionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filereactionPager struct {
	reverse bool
	order   *FileReactionOrder
	filter  func(*FileReactionQuery) (*FileReactionQuery, error)
}

func newFileReactionPager(opts []FileReactionPaginateOption, reverse bool) (*filereactionPager, error) {
	pager := &filereactionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileReactionOrder
	}
	return pager, nil
}

func (p *filereactionPager) applyFilter(query *FileReactionQuery) (*FileReactionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filereactionPager) toCursor(_m *FileReaction) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *filereactionPager) applyCursors(query *FileReactionQuery, after, before *Cursor) (*FileReactionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileReactionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filereactionPager) applyOrder(query *FileReactionQuery) *FileReactionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileReactionOrder.Field {
		query = query.Order(DefaultFileReactionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filereactionPager) orderExpr(query *FileReactionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileReactionOrder.Field {
			b.Comma().Ident(DefaultFileReactionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileReaction.
func (_m *FileReactionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileReactionPaginateOption,
) (*FileReactionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileReactionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FileReactionConnection{Edges: []*FileReactionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileReactionOrderField defines the ordering field of FileReaction.
type FileReactionOrderField struct {
	// Value extracts the ordering value from the given FileReaction.
	Value    func(*FileReaction) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filereaction.OrderOption
	toCursor func(*FileReaction) Cursor
}

// FileReactionOrder defines the ordering of FileReaction.
type FileReactionOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *FileReactionOrderField `json:"field"`
}

// DefaultFileReactionOrder is the default ordering of FileReaction.
var DefaultFileReactionOrder = &FileReactionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileReactionOrderField{
		Value: func(_m *FileReaction) (ent.Value, error) {
			return _m.ID, nil
		},
		column: filereaction.FieldID,
		toTerm: filereaction.ByID,
		toCursor: func(_m *FileReaction) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FileReaction into FileReactionEdge.
func (_m *FileReaction) ToEdge(order *FileReactionOrder) *FileReactionEdge {
	if order == nil {
		order = DefaultFileReactionOrder
	}
	return &FileReactionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GameEdge is the edge representation of Game.
type GameEdge struct {
	Node   *Game  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GameConnection is the connection containing edges to Game.
type GameConnection struct {
	Edges      []*GameEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *GameConnection) build(nodes []*Game, pager *gamePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Game
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Game {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Game {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GamePaginateOption enables pagination customization.
type GamePaginateOption func(*gamePager) error

// WithGameOrder configures pagination ordering.
func WithGameOrder(order *GameOrder) GamePaginateOption {
	if order == nil {
		order = DefaultGameOrder
	}
	o := *order
	return func(pager *gamePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameFilter configures pagination filter.
func WithGameFilter(filter func(*GameQuery) (*GameQuery, error)) GamePaginateOption {
	return func(pager *gamePager) error {
		if filter == nil {
			return errors.New("GameQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamePager struct {
	reverse bool
	order   *GameOrder
	filter  func(*GameQuery) (*GameQuery, error)
}

func newGamePager(opts []GamePaginateOption, reverse bool) (*gamePager, error) {
	pager := &gamePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameOrder
	}
	return pager, nil
}

func (p *gamePager) applyFilter(query *GameQuery) (*GameQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamePager) toCursor(_m *Game) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *gamePager) applyCursors(query *GameQuery, after, before *Cursor) (*GameQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamePager) applyOrder(query *GameQuery) *GameQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameOrder.Field {
		query = query.Order(DefaultGameOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamePager) orderExpr(query *GameQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameOrder.Field {
			b.Comma().Ident(DefaultGameOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Game.
func (_m *GameQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GamePaginateOption,
) (*GameConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGamePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GameConnection{Edges: []*GameEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameOrderField defines the ordering field of Game.
type GameOrderField struct {
	// Value extracts the ordering value from the given Game.
	Value    func(*Game) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) game.OrderOption
	toCursor func(*Game) Cursor
}

// GameOrder defines the ordering of Game.
type GameOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *GameOrderField `json:"field"`
}

// DefaultGameOrder is the default ordering of Game.
var DefaultGameOrder = &GameOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameOrderField{
		Value: func(_m *Game) (ent.Value, error) {
			return _m.ID, nil
		},
		column: game.FieldID,
		toTerm: game.ByID,
		toCursor: func(_m *Game) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Game into GameEdge.
func (_m *Game) ToEdge(order *GameOrder) *GameEdge {
	if order == nil {
		order = DefaultGameOrder
	}
	return &GameEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GameLikeEdge is the edge representation of GameLike.
type GameLikeEdge struct {
	Node   *GameLike `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// GameLikeConnection is the connection containing edges to GameLike.
type GameLikeConnection struct {
	Edges      []*GameLikeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *GameLikeConnection) build(nodes []*GameLike, pager *gamelikePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GameLike
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GameLike {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GameLike {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameLikeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameLikeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GameLikePaginateOption enables pagination customization.
type GameLikePaginateOption func(*gamelikePager) error

// WithGameLikeOrder configures pagination ordering.
func WithGameLikeOrder(order *GameLikeOrder) GameLikePaginateOption {
	if order == nil {
		order = DefaultGameLikeOrder
	}
	o := *order
	return func(pager *gamelikePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameLikeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameLikeFilter configures pagination filter.
func WithGameLikeFilter(filter func(*GameLikeQuery) (*GameLikeQuery, error)) GameLikePaginateOption {
	return func(pager *gamelikePager) error {
		if filter == nil {
			return errors.New("GameLikeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamelikePager struct {
	reverse bool
	order   *GameLikeOrder
	filter  func(*GameLikeQuery) (*GameLikeQuery, error)
}

func newGameLikePager(opts []GameLikePaginateOption, reverse bool) (*gamelikePager, error) {
	pager := &gamelikePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameLikeOrder
	}
	return pager, nil
}

func (p *gamelikePager) applyFilter(query *GameLikeQuery) (*GameLikeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamelikePager) toCursor(_m *GameLike) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *gamelikePager) applyCursors(query *GameLikeQuery, after, before *Cursor) (*GameLikeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameLikeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamelikePager) applyOrder(query *GameLikeQuery) *GameLikeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameLikeOrder.Field {
		query = query.Order(DefaultGameLikeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamelikePager) orderExpr(query *GameLikeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameLikeOrder.Field {
			b.Comma().Ident(DefaultGameLikeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GameLike.
func (_m *GameLikeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GameLikePaginateOption,
) (*GameLikeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGameLikePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GameLikeConnection{Edges: []*GameLikeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameLikeOrderField defines the ordering field of GameLike.
type GameLikeOrderField struct {
	// Value extracts the ordering value from the given GameLike.
	Value    func(*GameLike) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) gamelike.OrderOption
	toCursor func(*GameLike) Cursor
}

// GameLikeOrder defines the ordering of GameLike.
type GameLikeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *GameLikeOrderField `json:"field"`
}

// DefaultGameLikeOrder is the default ordering of GameLike.
var DefaultGameLikeOrder = &GameLikeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameLikeOrderField{
		Value: func(_m *GameLike) (ent.Value, error) {
			return _m.ID, nil
		},
		column: gamelike.FieldID,
		toTerm: gamelike.ByID,
		toCursor: func(_m *GameLike) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GameLike into GameLikeEdge.
func (_m *GameLike) ToEdge(order *GameLikeOrder) *GameLikeEdge {
	if order == nil {
		order = DefaultGameLikeOrder
	}
	return &GameLikeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ImageEdge is the edge representation of Image.
type ImageEdge struct {
	Node   *Image `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ImageConnection is the connection containing edges to Image.
type ImageConnection struct {
	Edges      []*ImageEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ImageConnection) build(nodes []*Image, pager *imagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Image
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Image {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Image {
			return nodes[i]
		}
	}
	c.Edges = make([]*ImageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ImageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ImagePaginateOption enables pagination customization.
type ImagePaginateOption func(*imagePager) error

// WithImageOrder configures pagination ordering.
func WithImageOrder(order *ImageOrder) ImagePaginateOption {
	if order == nil {
		order = DefaultImageOrder
	}
	o := *order
	return func(pager *imagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultImageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithImageFilter configures pagination filter.
func WithImageFilter(filter func(*ImageQuery) (*ImageQuery, error)) ImagePaginateOption {
	return func(pager *imagePager) error {
		if filter == nil {
			return errors.New("ImageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type imagePager struct {
	reverse bool
	order   *ImageOrder
	filter  func(*ImageQuery) (*ImageQuery, error)
}

func newImagePager(opts []ImagePaginateOption, reverse bool) (*imagePager, error) {
	pager := &imagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultImageOrder
	}
	return pager, nil
}

func (p *imagePager) applyFilter(query *ImageQuery) (*ImageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *imagePager) toCursor(_m *Image) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *imagePager) applyCursors(query *ImageQuery, after, before *Cursor) (*ImageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultImageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *imagePager) applyOrder(query *ImageQuery) *ImageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultImageOrder.Field {
		query = query.Order(DefaultImageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *imagePager) orderExpr(query *ImageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultImageOrder.Field {
			b.Comma().Ident(DefaultImageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Image.
func (_m *ImageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ImagePaginateOption,
) (*ImageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newImagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ImageConnection{Edges: []*ImageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ImageOrderField defines the ordering field of Image.
type ImageOrderField struct {
	// Value extracts the ordering value from the given Image.
	Value    func(*Image) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) image.OrderOption
	toCursor func(*Image) Cursor
}

// ImageOrder defines the ordering of Image.
type ImageOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ImageOrderField `json:"field"`
}

// DefaultImageOrder is the default ordering of Image.
var DefaultImageOrder = &ImageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ImageOrderField{
		Value: func(_m *Image) (ent.Value, error) {
			return _m.ID, nil
		},
		column: image.FieldID,
		toTerm: image.ByID,
		toCursor: func(_m *Image) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Image into ImageEdge.
func (_m *Image) ToEdge(order *ImageOrder) *ImageEdge {
	if order == nil {
		order = DefaultImageOrder
	}
	return &ImageEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ReportEdge is the edge representation of Report.
type ReportEdge struct {
	Node   *Report `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ReportConnection is the connection containing edges to Report.
type ReportConnection struct {
	Edges      []*ReportEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ReportConnection) build(nodes []*Report, pager *reportPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Report
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Report {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Report {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReportEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReportEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReportPaginateOption enables pagination customization.
type ReportPaginateOption func(*reportPager) error

// WithReportOrder configures pagination ordering.
func WithReportOrder(order *ReportOrder) ReportPaginateOption {
	if order == nil {
		order = DefaultReportOrder
	}
	o := *order
	return func(pager *reportPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReportOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReportFilter configures pagination filter.
func WithReportFilter(filter func(*ReportQuery) (*ReportQuery, error)) ReportPaginateOption {
	return func(pager *reportPager) error {
		if filter == nil {
			return errors.New("ReportQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reportPager struct {
	reverse bool
	order   *ReportOrder
	filter  func(*ReportQuery) (*ReportQuery, error)
}

func newReportPager(opts []ReportPaginateOption, reverse bool) (*reportPager, error) {
	pager := &reportPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReportOrder
	}
	return pager, nil
}

func (p *reportPager) applyFilter(query *ReportQuery) (*ReportQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reportPager) toCursor(_m *Report) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *reportPager) applyCursors(query *ReportQuery, after, before *Cursor) (*ReportQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReportOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *reportPager) applyOrder(query *ReportQuery) *ReportQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReportOrder.Field {
		query = query.Order(DefaultReportOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *reportPager) orderExpr(query *ReportQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReportOrder.Field {
			b.Comma().Ident(DefaultReportOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Report.
func (_m *ReportQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReportPaginateOption,
) (*ReportConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReportPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ReportConnection{Edges: []*ReportEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ReportOrderField defines the ordering field of Report.
type ReportOrderField struct {
	// Value extracts the ordering value from the given Report.
	Value    func(*Report) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) report.OrderOption
	toCursor func(*Report) Cursor
}

// ReportOrder defines the ordering of Report.
type ReportOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ReportOrderField `json:"field"`
}

// DefaultReportOrder is the default ordering of Report.
var DefaultReportOrder = &ReportOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReportOrderField{
		Value: func(_m *Report) (ent.Value, error) {
			return _m.ID, nil
		},
		column: report.FieldID,
		toTerm: report.ByID,
		toCursor: func(_m *Report) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Report into ReportEdge.
func (_m *Report) ToEdge(order *ReportOrder) *ReportEdge {
	if order == nil {
		order = DefaultReportOrder
	}
	return &ReportEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SiteSettingEdge is the edge representation of SiteSetting.
type SiteSettingEdge struct {
	Node   *SiteSetting `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// SiteSettingConnection is the connection containing edges to SiteSetting.
type SiteSettingConnection struct {
	Edges      []*SiteSettingEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *SiteSettingConnection) build(nodes []*SiteSetting, pager *sitesettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SiteSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SiteSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SiteSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*SiteSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SiteSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SiteSettingPaginateOption enables pagination customization.
type SiteSettingPaginateOption func(*sitesettingPager) error

// WithSiteSettingOrder configures pagination ordering.
func WithSiteSettingOrder(order *SiteSettingOrder) SiteSettingPaginateOption {
	if order == nil {
		order = DefaultSiteSettingOrder
	}
	o := *order
	return func(pager *sitesettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSiteSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSiteSettingFilter configures pagination filter.
func WithSiteSettingFilter(filter func(*SiteSettingQuery) (*SiteSettingQuery, error)) SiteSettingPaginateOption {
	return func(pager *sitesettingPager) error {
		if filter == nil {
			return errors.New("SiteSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sitesettingPager struct {
	reverse bool
	order   *SiteSettingOrder
	filter  func(*SiteSettingQuery) (*SiteSettingQuery, error)
}

func newSiteSettingPager(opts []SiteSettingPaginateOption, reverse bool) (*sitesettingPager, error) {
	pager := &sitesettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSiteSettingOrder
	}
	return pager, nil
}

func (p *sitesettingPager) applyFilter(query *SiteSettingQuery) (*SiteSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sitesettingPager) toCursor(_m *SiteSetting) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *sitesettingPager) applyCursors(query *SiteSettingQuery, after, before *Cursor) (*SiteSettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSiteSettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *sitesettingPager) applyOrder(query *SiteSettingQuery) *SiteSettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSiteSettingOrder.Field {
		query = query.Order(DefaultSiteSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *sitesettingPager) orderExpr(query *SiteSettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSiteSettingOrder.Field {
			b.Comma().Ident(DefaultSiteSettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SiteSetting.
func (_m *SiteSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SiteSettingPaginateOption,
) (*SiteSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSiteSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SiteSettingConnection{Edges: []*SiteSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SiteSettingOrderField defines the ordering field of SiteSetting.
type SiteSettingOrderField struct {
	// Value extracts the ordering value from the given SiteSetting.
	Value    func(*SiteSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) sitesetting.OrderOption
	toCursor func(*SiteSetting) Cursor
}

// SiteSettingOrder defines the ordering of SiteSetting.
type SiteSettingOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *SiteSettingOrderField `json:"field"`
}

// DefaultSiteSettingOrder is the default ordering of SiteSetting.
var DefaultSiteSettingOrder = &SiteSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SiteSettingOrderField{
		Value: func(_m *SiteSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: sitesetting.FieldID,
		toTerm: sitesetting.ByID,
		toCursor: func(_m *SiteSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts SiteSetting into SiteSettingEdge.
func (_m *SiteSetting) ToEdge(order *SiteSettingOrder) *SiteSettingEdge {
	if order == nil {
		order = DefaultSiteSettingOrder
	}
	return &SiteSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserShadowEdge is the edge representation of UserShadow.
type UserShadowEdge struct {
	Node   *UserShadow `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// UserShadowConnection is the connection containing edges to UserShadow.
type UserShadowConnection struct {
	Edges      []*UserShadowEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *UserShadowConnection) build(nodes []*UserShadow, pager *usershadowPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserShadow
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserShadow {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserShadow {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserShadowEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserShadowEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserShadowPaginateOption enables pagination customization.
type UserShadowPaginateOption func(*usershadowPager) error

// WithUserShadowOrder configures pagination ordering.
func WithUserShadowOrder(order *UserShadowOrder) UserShadowPaginateOption {
	if order == nil {
		order = DefaultUserShadowOrder
	}
	o := *order
	return func(pager *usershadowPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserShadowOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserShadowFilter configures pagination filter.
func WithUserShadowFilter(filter func(*UserShadowQuery) (*UserShadowQuery, error)) UserShadowPaginateOption {
	return func(pager *usershadowPager) error {
		if filter == nil {
			return errors.New("UserShadowQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usershadowPager struct {
	reverse bool
	order   *UserShadowOrder
	filter  func(*UserShadowQuery) (*UserShadowQuery, error)
}

func newUserShadowPager(opts []UserShadowPaginateOption, reverse bool) (*usershadowPager, error) {
	pager := &usershadowPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserShadowOrder
	}
	return pager, nil
}

func (p *usershadowPager) applyFilter(query *UserShadowQuery) (*UserShadowQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usershadowPager) toCursor(_m *UserShadow) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *usershadowPager) applyCursors(query *UserShadowQuery, after, before *Cursor) (*UserShadowQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserShadowOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usershadowPager) applyOrder(query *UserShadowQuery) *UserShadowQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserShadowOrder.Field {
		query = query.Order(DefaultUserShadowOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usershadowPager) orderExpr(query *UserShadowQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserShadowOrder.Field {
			b.Comma().Ident(DefaultUserShadowOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserShadow.
func (_m *UserShadowQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserShadowPaginateOption,
) (*UserShadowConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserShadowPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserShadowConnection{Edges: []*UserShadowEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserShadowOrderField defines the ordering field of UserShadow.
type UserShadowOrderField struct {
	// Value extracts the ordering value from the given UserShadow.
	Value    func(*UserShadow) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usershadow.OrderOption
	toCursor func(*UserShadow) Cursor
}

// UserShadowOrder defines the ordering of UserShadow.
type UserShadowOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *UserShadowOrderField `json:"field"`
}

// DefaultUserShadowOrder is the default ordering of UserShadow.
var DefaultUserShadowOrder = &UserShadowOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserShadowOrderField{
		Value: func(_m *UserShadow) (ent.Value, error) {
			return _m.ID, nil
		},
		column: usershadow.FieldID,
		toTerm: usershadow.ByID,
		toCursor: func(_m *UserShadow) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserShadow into UserShadowEdge.
func (_m *UserShadow) ToEdge(order *UserShadowOrder) *UserShadowEdge {
	if order == nil {
		order = DefaultUserShadowOrder
	}
	return &UserShadowEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
