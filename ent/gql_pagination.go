// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/game"
	"github.com/deicod/archivedgames/ent/image"
	"github.com/deicod/archivedgames/ent/report"
	"github.com/deicod/archivedgames/ent/sitesetting"
	"github.com/deicod/archivedgames/ent/usershadow"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   *FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileOrder.Field {
			b.Comma().Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := f.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (f *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// GameEdge is the edge representation of Game.
type GameEdge struct {
	Node   *Game  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GameConnection is the connection containing edges to Game.
type GameConnection struct {
	Edges      []*GameEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *GameConnection) build(nodes []*Game, pager *gamePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Game
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Game {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Game {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GamePaginateOption enables pagination customization.
type GamePaginateOption func(*gamePager) error

// WithGameOrder configures pagination ordering.
func WithGameOrder(order *GameOrder) GamePaginateOption {
	if order == nil {
		order = DefaultGameOrder
	}
	o := *order
	return func(pager *gamePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameFilter configures pagination filter.
func WithGameFilter(filter func(*GameQuery) (*GameQuery, error)) GamePaginateOption {
	return func(pager *gamePager) error {
		if filter == nil {
			return errors.New("GameQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamePager struct {
	reverse bool
	order   *GameOrder
	filter  func(*GameQuery) (*GameQuery, error)
}

func newGamePager(opts []GamePaginateOption, reverse bool) (*gamePager, error) {
	pager := &gamePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameOrder
	}
	return pager, nil
}

func (p *gamePager) applyFilter(query *GameQuery) (*GameQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamePager) toCursor(ga *Game) Cursor {
	return p.order.Field.toCursor(ga)
}

func (p *gamePager) applyCursors(query *GameQuery, after, before *Cursor) (*GameQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamePager) applyOrder(query *GameQuery) *GameQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameOrder.Field {
		query = query.Order(DefaultGameOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamePager) orderExpr(query *GameQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameOrder.Field {
			b.Comma().Ident(DefaultGameOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Game.
func (ga *GameQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GamePaginateOption,
) (*GameConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGamePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ga, err = pager.applyFilter(ga); err != nil {
		return nil, err
	}
	conn := &GameConnection{Edges: []*GameEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ga.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ga, err = pager.applyCursors(ga, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ga.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ga.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ga = pager.applyOrder(ga)
	nodes, err := ga.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameOrderField defines the ordering field of Game.
type GameOrderField struct {
	// Value extracts the ordering value from the given Game.
	Value    func(*Game) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) game.OrderOption
	toCursor func(*Game) Cursor
}

// GameOrder defines the ordering of Game.
type GameOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *GameOrderField `json:"field"`
}

// DefaultGameOrder is the default ordering of Game.
var DefaultGameOrder = &GameOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameOrderField{
		Value: func(ga *Game) (ent.Value, error) {
			return ga.ID, nil
		},
		column: game.FieldID,
		toTerm: game.ByID,
		toCursor: func(ga *Game) Cursor {
			return Cursor{ID: ga.ID}
		},
	},
}

// ToEdge converts Game into GameEdge.
func (ga *Game) ToEdge(order *GameOrder) *GameEdge {
	if order == nil {
		order = DefaultGameOrder
	}
	return &GameEdge{
		Node:   ga,
		Cursor: order.Field.toCursor(ga),
	}
}

// ImageEdge is the edge representation of Image.
type ImageEdge struct {
	Node   *Image `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ImageConnection is the connection containing edges to Image.
type ImageConnection struct {
	Edges      []*ImageEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ImageConnection) build(nodes []*Image, pager *imagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Image
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Image {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Image {
			return nodes[i]
		}
	}
	c.Edges = make([]*ImageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ImageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ImagePaginateOption enables pagination customization.
type ImagePaginateOption func(*imagePager) error

// WithImageOrder configures pagination ordering.
func WithImageOrder(order *ImageOrder) ImagePaginateOption {
	if order == nil {
		order = DefaultImageOrder
	}
	o := *order
	return func(pager *imagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultImageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithImageFilter configures pagination filter.
func WithImageFilter(filter func(*ImageQuery) (*ImageQuery, error)) ImagePaginateOption {
	return func(pager *imagePager) error {
		if filter == nil {
			return errors.New("ImageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type imagePager struct {
	reverse bool
	order   *ImageOrder
	filter  func(*ImageQuery) (*ImageQuery, error)
}

func newImagePager(opts []ImagePaginateOption, reverse bool) (*imagePager, error) {
	pager := &imagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultImageOrder
	}
	return pager, nil
}

func (p *imagePager) applyFilter(query *ImageQuery) (*ImageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *imagePager) toCursor(i *Image) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *imagePager) applyCursors(query *ImageQuery, after, before *Cursor) (*ImageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultImageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *imagePager) applyOrder(query *ImageQuery) *ImageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultImageOrder.Field {
		query = query.Order(DefaultImageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *imagePager) orderExpr(query *ImageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultImageOrder.Field {
			b.Comma().Ident(DefaultImageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Image.
func (i *ImageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ImagePaginateOption,
) (*ImageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newImagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &ImageConnection{Edges: []*ImageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := i.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ImageOrderField defines the ordering field of Image.
type ImageOrderField struct {
	// Value extracts the ordering value from the given Image.
	Value    func(*Image) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) image.OrderOption
	toCursor func(*Image) Cursor
}

// ImageOrder defines the ordering of Image.
type ImageOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ImageOrderField `json:"field"`
}

// DefaultImageOrder is the default ordering of Image.
var DefaultImageOrder = &ImageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ImageOrderField{
		Value: func(i *Image) (ent.Value, error) {
			return i.ID, nil
		},
		column: image.FieldID,
		toTerm: image.ByID,
		toCursor: func(i *Image) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Image into ImageEdge.
func (i *Image) ToEdge(order *ImageOrder) *ImageEdge {
	if order == nil {
		order = DefaultImageOrder
	}
	return &ImageEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// ReportEdge is the edge representation of Report.
type ReportEdge struct {
	Node   *Report `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ReportConnection is the connection containing edges to Report.
type ReportConnection struct {
	Edges      []*ReportEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ReportConnection) build(nodes []*Report, pager *reportPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Report
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Report {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Report {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReportEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReportEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReportPaginateOption enables pagination customization.
type ReportPaginateOption func(*reportPager) error

// WithReportOrder configures pagination ordering.
func WithReportOrder(order *ReportOrder) ReportPaginateOption {
	if order == nil {
		order = DefaultReportOrder
	}
	o := *order
	return func(pager *reportPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReportOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReportFilter configures pagination filter.
func WithReportFilter(filter func(*ReportQuery) (*ReportQuery, error)) ReportPaginateOption {
	return func(pager *reportPager) error {
		if filter == nil {
			return errors.New("ReportQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reportPager struct {
	reverse bool
	order   *ReportOrder
	filter  func(*ReportQuery) (*ReportQuery, error)
}

func newReportPager(opts []ReportPaginateOption, reverse bool) (*reportPager, error) {
	pager := &reportPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReportOrder
	}
	return pager, nil
}

func (p *reportPager) applyFilter(query *ReportQuery) (*ReportQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reportPager) toCursor(r *Report) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *reportPager) applyCursors(query *ReportQuery, after, before *Cursor) (*ReportQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReportOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *reportPager) applyOrder(query *ReportQuery) *ReportQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReportOrder.Field {
		query = query.Order(DefaultReportOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *reportPager) orderExpr(query *ReportQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReportOrder.Field {
			b.Comma().Ident(DefaultReportOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Report.
func (r *ReportQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReportPaginateOption,
) (*ReportConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReportPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &ReportConnection{Edges: []*ReportEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ReportOrderField defines the ordering field of Report.
type ReportOrderField struct {
	// Value extracts the ordering value from the given Report.
	Value    func(*Report) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) report.OrderOption
	toCursor func(*Report) Cursor
}

// ReportOrder defines the ordering of Report.
type ReportOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ReportOrderField `json:"field"`
}

// DefaultReportOrder is the default ordering of Report.
var DefaultReportOrder = &ReportOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReportOrderField{
		Value: func(r *Report) (ent.Value, error) {
			return r.ID, nil
		},
		column: report.FieldID,
		toTerm: report.ByID,
		toCursor: func(r *Report) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Report into ReportEdge.
func (r *Report) ToEdge(order *ReportOrder) *ReportEdge {
	if order == nil {
		order = DefaultReportOrder
	}
	return &ReportEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SiteSettingEdge is the edge representation of SiteSetting.
type SiteSettingEdge struct {
	Node   *SiteSetting `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// SiteSettingConnection is the connection containing edges to SiteSetting.
type SiteSettingConnection struct {
	Edges      []*SiteSettingEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *SiteSettingConnection) build(nodes []*SiteSetting, pager *sitesettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SiteSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SiteSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SiteSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*SiteSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SiteSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SiteSettingPaginateOption enables pagination customization.
type SiteSettingPaginateOption func(*sitesettingPager) error

// WithSiteSettingOrder configures pagination ordering.
func WithSiteSettingOrder(order *SiteSettingOrder) SiteSettingPaginateOption {
	if order == nil {
		order = DefaultSiteSettingOrder
	}
	o := *order
	return func(pager *sitesettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSiteSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSiteSettingFilter configures pagination filter.
func WithSiteSettingFilter(filter func(*SiteSettingQuery) (*SiteSettingQuery, error)) SiteSettingPaginateOption {
	return func(pager *sitesettingPager) error {
		if filter == nil {
			return errors.New("SiteSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sitesettingPager struct {
	reverse bool
	order   *SiteSettingOrder
	filter  func(*SiteSettingQuery) (*SiteSettingQuery, error)
}

func newSiteSettingPager(opts []SiteSettingPaginateOption, reverse bool) (*sitesettingPager, error) {
	pager := &sitesettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSiteSettingOrder
	}
	return pager, nil
}

func (p *sitesettingPager) applyFilter(query *SiteSettingQuery) (*SiteSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sitesettingPager) toCursor(ss *SiteSetting) Cursor {
	return p.order.Field.toCursor(ss)
}

func (p *sitesettingPager) applyCursors(query *SiteSettingQuery, after, before *Cursor) (*SiteSettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSiteSettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *sitesettingPager) applyOrder(query *SiteSettingQuery) *SiteSettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSiteSettingOrder.Field {
		query = query.Order(DefaultSiteSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *sitesettingPager) orderExpr(query *SiteSettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSiteSettingOrder.Field {
			b.Comma().Ident(DefaultSiteSettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SiteSetting.
func (ss *SiteSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SiteSettingPaginateOption,
) (*SiteSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSiteSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ss, err = pager.applyFilter(ss); err != nil {
		return nil, err
	}
	conn := &SiteSettingConnection{Edges: []*SiteSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ss.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ss, err = pager.applyCursors(ss, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ss.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ss.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ss = pager.applyOrder(ss)
	nodes, err := ss.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SiteSettingOrderField defines the ordering field of SiteSetting.
type SiteSettingOrderField struct {
	// Value extracts the ordering value from the given SiteSetting.
	Value    func(*SiteSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) sitesetting.OrderOption
	toCursor func(*SiteSetting) Cursor
}

// SiteSettingOrder defines the ordering of SiteSetting.
type SiteSettingOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *SiteSettingOrderField `json:"field"`
}

// DefaultSiteSettingOrder is the default ordering of SiteSetting.
var DefaultSiteSettingOrder = &SiteSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SiteSettingOrderField{
		Value: func(ss *SiteSetting) (ent.Value, error) {
			return ss.ID, nil
		},
		column: sitesetting.FieldID,
		toTerm: sitesetting.ByID,
		toCursor: func(ss *SiteSetting) Cursor {
			return Cursor{ID: ss.ID}
		},
	},
}

// ToEdge converts SiteSetting into SiteSettingEdge.
func (ss *SiteSetting) ToEdge(order *SiteSettingOrder) *SiteSettingEdge {
	if order == nil {
		order = DefaultSiteSettingOrder
	}
	return &SiteSettingEdge{
		Node:   ss,
		Cursor: order.Field.toCursor(ss),
	}
}

// UserShadowEdge is the edge representation of UserShadow.
type UserShadowEdge struct {
	Node   *UserShadow `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// UserShadowConnection is the connection containing edges to UserShadow.
type UserShadowConnection struct {
	Edges      []*UserShadowEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *UserShadowConnection) build(nodes []*UserShadow, pager *usershadowPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserShadow
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserShadow {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserShadow {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserShadowEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserShadowEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserShadowPaginateOption enables pagination customization.
type UserShadowPaginateOption func(*usershadowPager) error

// WithUserShadowOrder configures pagination ordering.
func WithUserShadowOrder(order *UserShadowOrder) UserShadowPaginateOption {
	if order == nil {
		order = DefaultUserShadowOrder
	}
	o := *order
	return func(pager *usershadowPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserShadowOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserShadowFilter configures pagination filter.
func WithUserShadowFilter(filter func(*UserShadowQuery) (*UserShadowQuery, error)) UserShadowPaginateOption {
	return func(pager *usershadowPager) error {
		if filter == nil {
			return errors.New("UserShadowQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usershadowPager struct {
	reverse bool
	order   *UserShadowOrder
	filter  func(*UserShadowQuery) (*UserShadowQuery, error)
}

func newUserShadowPager(opts []UserShadowPaginateOption, reverse bool) (*usershadowPager, error) {
	pager := &usershadowPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserShadowOrder
	}
	return pager, nil
}

func (p *usershadowPager) applyFilter(query *UserShadowQuery) (*UserShadowQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usershadowPager) toCursor(us *UserShadow) Cursor {
	return p.order.Field.toCursor(us)
}

func (p *usershadowPager) applyCursors(query *UserShadowQuery, after, before *Cursor) (*UserShadowQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserShadowOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usershadowPager) applyOrder(query *UserShadowQuery) *UserShadowQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserShadowOrder.Field {
		query = query.Order(DefaultUserShadowOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usershadowPager) orderExpr(query *UserShadowQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserShadowOrder.Field {
			b.Comma().Ident(DefaultUserShadowOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserShadow.
func (us *UserShadowQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserShadowPaginateOption,
) (*UserShadowConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserShadowPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if us, err = pager.applyFilter(us); err != nil {
		return nil, err
	}
	conn := &UserShadowConnection{Edges: []*UserShadowEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := us.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if us, err = pager.applyCursors(us, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		us.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := us.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	us = pager.applyOrder(us)
	nodes, err := us.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserShadowOrderField defines the ordering field of UserShadow.
type UserShadowOrderField struct {
	// Value extracts the ordering value from the given UserShadow.
	Value    func(*UserShadow) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usershadow.OrderOption
	toCursor func(*UserShadow) Cursor
}

// UserShadowOrder defines the ordering of UserShadow.
type UserShadowOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *UserShadowOrderField `json:"field"`
}

// DefaultUserShadowOrder is the default ordering of UserShadow.
var DefaultUserShadowOrder = &UserShadowOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserShadowOrderField{
		Value: func(us *UserShadow) (ent.Value, error) {
			return us.ID, nil
		},
		column: usershadow.FieldID,
		toTerm: usershadow.ByID,
		toCursor: func(us *UserShadow) Cursor {
			return Cursor{ID: us.ID}
		},
	},
}

// ToEdge converts UserShadow into UserShadowEdge.
func (us *UserShadow) ToEdge(order *UserShadowOrder) *UserShadowEdge {
	if order == nil {
		order = DefaultUserShadowOrder
	}
	return &UserShadowEdge{
		Node:   us,
		Cursor: order.Field.toCursor(us),
	}
}
