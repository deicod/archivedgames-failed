// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/deicod/archivedgames/ent/comment"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/filegroup"
	"github.com/deicod/archivedgames/ent/filereaction"
	"github.com/deicod/archivedgames/ent/game"
	"github.com/deicod/archivedgames/ent/gamelike"
	"github.com/deicod/archivedgames/ent/image"
	"github.com/deicod/archivedgames/ent/predicate"
	"github.com/deicod/archivedgames/ent/report"
	"github.com/deicod/archivedgames/ent/sitesetting"
	"github.com/deicod/archivedgames/ent/usershadow"
)

// CommentWhereInput represents a where input for filtering Comment queries.
type CommentWhereInput struct {
	Predicates []predicate.Comment  `json:"-"`
	Not        *CommentWhereInput   `json:"not,omitempty"`
	Or         []*CommentWhereInput `json:"or,omitempty"`
	And        []*CommentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "subject_type" field predicates.
	SubjectType             *string  `json:"subjectType,omitempty"`
	SubjectTypeNEQ          *string  `json:"subjectTypeNEQ,omitempty"`
	SubjectTypeIn           []string `json:"subjectTypeIn,omitempty"`
	SubjectTypeNotIn        []string `json:"subjectTypeNotIn,omitempty"`
	SubjectTypeGT           *string  `json:"subjectTypeGT,omitempty"`
	SubjectTypeGTE          *string  `json:"subjectTypeGTE,omitempty"`
	SubjectTypeLT           *string  `json:"subjectTypeLT,omitempty"`
	SubjectTypeLTE          *string  `json:"subjectTypeLTE,omitempty"`
	SubjectTypeContains     *string  `json:"subjectTypeContains,omitempty"`
	SubjectTypeHasPrefix    *string  `json:"subjectTypeHasPrefix,omitempty"`
	SubjectTypeHasSuffix    *string  `json:"subjectTypeHasSuffix,omitempty"`
	SubjectTypeEqualFold    *string  `json:"subjectTypeEqualFold,omitempty"`
	SubjectTypeContainsFold *string  `json:"subjectTypeContainsFold,omitempty"`

	// "subject_id" field predicates.
	SubjectID             *string  `json:"subjectID,omitempty"`
	SubjectIDNEQ          *string  `json:"subjectIDNEQ,omitempty"`
	SubjectIDIn           []string `json:"subjectIDIn,omitempty"`
	SubjectIDNotIn        []string `json:"subjectIDNotIn,omitempty"`
	SubjectIDGT           *string  `json:"subjectIDGT,omitempty"`
	SubjectIDGTE          *string  `json:"subjectIDGTE,omitempty"`
	SubjectIDLT           *string  `json:"subjectIDLT,omitempty"`
	SubjectIDLTE          *string  `json:"subjectIDLTE,omitempty"`
	SubjectIDContains     *string  `json:"subjectIDContains,omitempty"`
	SubjectIDHasPrefix    *string  `json:"subjectIDHasPrefix,omitempty"`
	SubjectIDHasSuffix    *string  `json:"subjectIDHasSuffix,omitempty"`
	SubjectIDEqualFold    *string  `json:"subjectIDEqualFold,omitempty"`
	SubjectIDContainsFold *string  `json:"subjectIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "language" field predicates.
	Language             *string  `json:"language,omitempty"`
	LanguageNEQ          *string  `json:"languageNEQ,omitempty"`
	LanguageIn           []string `json:"languageIn,omitempty"`
	LanguageNotIn        []string `json:"languageNotIn,omitempty"`
	LanguageGT           *string  `json:"languageGT,omitempty"`
	LanguageGTE          *string  `json:"languageGTE,omitempty"`
	LanguageLT           *string  `json:"languageLT,omitempty"`
	LanguageLTE          *string  `json:"languageLTE,omitempty"`
	LanguageContains     *string  `json:"languageContains,omitempty"`
	LanguageHasPrefix    *string  `json:"languageHasPrefix,omitempty"`
	LanguageHasSuffix    *string  `json:"languageHasSuffix,omitempty"`
	LanguageIsNil        bool     `json:"languageIsNil,omitempty"`
	LanguageNotNil       bool     `json:"languageNotNil,omitempty"`
	LanguageEqualFold    *string  `json:"languageEqualFold,omitempty"`
	LanguageContainsFold *string  `json:"languageContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "edited_at" field predicates.
	EditedAt       *time.Time  `json:"editedAt,omitempty"`
	EditedAtNEQ    *time.Time  `json:"editedAtNEQ,omitempty"`
	EditedAtIn     []time.Time `json:"editedAtIn,omitempty"`
	EditedAtNotIn  []time.Time `json:"editedAtNotIn,omitempty"`
	EditedAtGT     *time.Time  `json:"editedAtGT,omitempty"`
	EditedAtGTE    *time.Time  `json:"editedAtGTE,omitempty"`
	EditedAtLT     *time.Time  `json:"editedAtLT,omitempty"`
	EditedAtLTE    *time.Time  `json:"editedAtLTE,omitempty"`
	EditedAtIsNil  bool        `json:"editedAtIsNil,omitempty"`
	EditedAtNotNil bool        `json:"editedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "game" edge predicates.
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`

	// "file" edge predicates.
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CommentWhereInput) AddPredicates(predicates ...predicate.Comment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CommentWhereInput filter on the CommentQuery builder.
func (i *CommentWhereInput) Filter(q *CommentQuery) (*CommentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCommentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCommentWhereInput is returned in case the CommentWhereInput is empty.
var ErrEmptyCommentWhereInput = errors.New("ent: empty predicate CommentWhereInput")

// P returns a predicate for filtering comments.
// An error is returned if the input is empty or invalid.
func (i *CommentWhereInput) P() (predicate.Comment, error) {
	var predicates []predicate.Comment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, comment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Comment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, comment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Comment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, comment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, comment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, comment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, comment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, comment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, comment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, comment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, comment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, comment.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, comment.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, comment.IDContainsFold(*i.IDContainsFold))
	}
	if i.SubjectType != nil {
		predicates = append(predicates, comment.SubjectTypeEQ(*i.SubjectType))
	}
	if i.SubjectTypeNEQ != nil {
		predicates = append(predicates, comment.SubjectTypeNEQ(*i.SubjectTypeNEQ))
	}
	if len(i.SubjectTypeIn) > 0 {
		predicates = append(predicates, comment.SubjectTypeIn(i.SubjectTypeIn...))
	}
	if len(i.SubjectTypeNotIn) > 0 {
		predicates = append(predicates, comment.SubjectTypeNotIn(i.SubjectTypeNotIn...))
	}
	if i.SubjectTypeGT != nil {
		predicates = append(predicates, comment.SubjectTypeGT(*i.SubjectTypeGT))
	}
	if i.SubjectTypeGTE != nil {
		predicates = append(predicates, comment.SubjectTypeGTE(*i.SubjectTypeGTE))
	}
	if i.SubjectTypeLT != nil {
		predicates = append(predicates, comment.SubjectTypeLT(*i.SubjectTypeLT))
	}
	if i.SubjectTypeLTE != nil {
		predicates = append(predicates, comment.SubjectTypeLTE(*i.SubjectTypeLTE))
	}
	if i.SubjectTypeContains != nil {
		predicates = append(predicates, comment.SubjectTypeContains(*i.SubjectTypeContains))
	}
	if i.SubjectTypeHasPrefix != nil {
		predicates = append(predicates, comment.SubjectTypeHasPrefix(*i.SubjectTypeHasPrefix))
	}
	if i.SubjectTypeHasSuffix != nil {
		predicates = append(predicates, comment.SubjectTypeHasSuffix(*i.SubjectTypeHasSuffix))
	}
	if i.SubjectTypeEqualFold != nil {
		predicates = append(predicates, comment.SubjectTypeEqualFold(*i.SubjectTypeEqualFold))
	}
	if i.SubjectTypeContainsFold != nil {
		predicates = append(predicates, comment.SubjectTypeContainsFold(*i.SubjectTypeContainsFold))
	}
	if i.SubjectID != nil {
		predicates = append(predicates, comment.SubjectIDEQ(*i.SubjectID))
	}
	if i.SubjectIDNEQ != nil {
		predicates = append(predicates, comment.SubjectIDNEQ(*i.SubjectIDNEQ))
	}
	if len(i.SubjectIDIn) > 0 {
		predicates = append(predicates, comment.SubjectIDIn(i.SubjectIDIn...))
	}
	if len(i.SubjectIDNotIn) > 0 {
		predicates = append(predicates, comment.SubjectIDNotIn(i.SubjectIDNotIn...))
	}
	if i.SubjectIDGT != nil {
		predicates = append(predicates, comment.SubjectIDGT(*i.SubjectIDGT))
	}
	if i.SubjectIDGTE != nil {
		predicates = append(predicates, comment.SubjectIDGTE(*i.SubjectIDGTE))
	}
	if i.SubjectIDLT != nil {
		predicates = append(predicates, comment.SubjectIDLT(*i.SubjectIDLT))
	}
	if i.SubjectIDLTE != nil {
		predicates = append(predicates, comment.SubjectIDLTE(*i.SubjectIDLTE))
	}
	if i.SubjectIDContains != nil {
		predicates = append(predicates, comment.SubjectIDContains(*i.SubjectIDContains))
	}
	if i.SubjectIDHasPrefix != nil {
		predicates = append(predicates, comment.SubjectIDHasPrefix(*i.SubjectIDHasPrefix))
	}
	if i.SubjectIDHasSuffix != nil {
		predicates = append(predicates, comment.SubjectIDHasSuffix(*i.SubjectIDHasSuffix))
	}
	if i.SubjectIDEqualFold != nil {
		predicates = append(predicates, comment.SubjectIDEqualFold(*i.SubjectIDEqualFold))
	}
	if i.SubjectIDContainsFold != nil {
		predicates = append(predicates, comment.SubjectIDContainsFold(*i.SubjectIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, comment.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, comment.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, comment.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, comment.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, comment.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, comment.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, comment.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, comment.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, comment.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, comment.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, comment.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, comment.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, comment.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Language != nil {
		predicates = append(predicates, comment.LanguageEQ(*i.Language))
	}
	if i.LanguageNEQ != nil {
		predicates = append(predicates, comment.LanguageNEQ(*i.LanguageNEQ))
	}
	if len(i.LanguageIn) > 0 {
		predicates = append(predicates, comment.LanguageIn(i.LanguageIn...))
	}
	if len(i.LanguageNotIn) > 0 {
		predicates = append(predicates, comment.LanguageNotIn(i.LanguageNotIn...))
	}
	if i.LanguageGT != nil {
		predicates = append(predicates, comment.LanguageGT(*i.LanguageGT))
	}
	if i.LanguageGTE != nil {
		predicates = append(predicates, comment.LanguageGTE(*i.LanguageGTE))
	}
	if i.LanguageLT != nil {
		predicates = append(predicates, comment.LanguageLT(*i.LanguageLT))
	}
	if i.LanguageLTE != nil {
		predicates = append(predicates, comment.LanguageLTE(*i.LanguageLTE))
	}
	if i.LanguageContains != nil {
		predicates = append(predicates, comment.LanguageContains(*i.LanguageContains))
	}
	if i.LanguageHasPrefix != nil {
		predicates = append(predicates, comment.LanguageHasPrefix(*i.LanguageHasPrefix))
	}
	if i.LanguageHasSuffix != nil {
		predicates = append(predicates, comment.LanguageHasSuffix(*i.LanguageHasSuffix))
	}
	if i.LanguageIsNil {
		predicates = append(predicates, comment.LanguageIsNil())
	}
	if i.LanguageNotNil {
		predicates = append(predicates, comment.LanguageNotNil())
	}
	if i.LanguageEqualFold != nil {
		predicates = append(predicates, comment.LanguageEqualFold(*i.LanguageEqualFold))
	}
	if i.LanguageContainsFold != nil {
		predicates = append(predicates, comment.LanguageContainsFold(*i.LanguageContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, comment.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, comment.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, comment.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, comment.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, comment.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, comment.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, comment.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, comment.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, comment.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, comment.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, comment.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, comment.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, comment.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, comment.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, comment.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, comment.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, comment.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, comment.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, comment.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, comment.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, comment.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.EditedAt != nil {
		predicates = append(predicates, comment.EditedAtEQ(*i.EditedAt))
	}
	if i.EditedAtNEQ != nil {
		predicates = append(predicates, comment.EditedAtNEQ(*i.EditedAtNEQ))
	}
	if len(i.EditedAtIn) > 0 {
		predicates = append(predicates, comment.EditedAtIn(i.EditedAtIn...))
	}
	if len(i.EditedAtNotIn) > 0 {
		predicates = append(predicates, comment.EditedAtNotIn(i.EditedAtNotIn...))
	}
	if i.EditedAtGT != nil {
		predicates = append(predicates, comment.EditedAtGT(*i.EditedAtGT))
	}
	if i.EditedAtGTE != nil {
		predicates = append(predicates, comment.EditedAtGTE(*i.EditedAtGTE))
	}
	if i.EditedAtLT != nil {
		predicates = append(predicates, comment.EditedAtLT(*i.EditedAtLT))
	}
	if i.EditedAtLTE != nil {
		predicates = append(predicates, comment.EditedAtLTE(*i.EditedAtLTE))
	}
	if i.EditedAtIsNil {
		predicates = append(predicates, comment.EditedAtIsNil())
	}
	if i.EditedAtNotNil {
		predicates = append(predicates, comment.EditedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, comment.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, comment.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, comment.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, comment.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, comment.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, comment.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, comment.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, comment.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, comment.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, comment.DeletedAtNotNil())
	}

	if i.HasGame != nil {
		p := comment.HasGame()
		if !*i.HasGame {
			p = comment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGameWith) > 0 {
		with := make([]predicate.Game, 0, len(i.HasGameWith))
		for _, w := range i.HasGameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comment.HasGameWith(with...))
	}
	if i.HasFile != nil {
		p := comment.HasFile()
		if !*i.HasFile {
			p = comment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFileWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFileWith))
		for _, w := range i.HasFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comment.HasFileWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCommentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return comment.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "original_name" field predicates.
	OriginalName             *string  `json:"originalName,omitempty"`
	OriginalNameNEQ          *string  `json:"originalNameNEQ,omitempty"`
	OriginalNameIn           []string `json:"originalNameIn,omitempty"`
	OriginalNameNotIn        []string `json:"originalNameNotIn,omitempty"`
	OriginalNameGT           *string  `json:"originalNameGT,omitempty"`
	OriginalNameGTE          *string  `json:"originalNameGTE,omitempty"`
	OriginalNameLT           *string  `json:"originalNameLT,omitempty"`
	OriginalNameLTE          *string  `json:"originalNameLTE,omitempty"`
	OriginalNameContains     *string  `json:"originalNameContains,omitempty"`
	OriginalNameHasPrefix    *string  `json:"originalNameHasPrefix,omitempty"`
	OriginalNameHasSuffix    *string  `json:"originalNameHasSuffix,omitempty"`
	OriginalNameEqualFold    *string  `json:"originalNameEqualFold,omitempty"`
	OriginalNameContainsFold *string  `json:"originalNameContainsFold,omitempty"`

	// "normalized_name" field predicates.
	NormalizedName             *string  `json:"normalizedName,omitempty"`
	NormalizedNameNEQ          *string  `json:"normalizedNameNEQ,omitempty"`
	NormalizedNameIn           []string `json:"normalizedNameIn,omitempty"`
	NormalizedNameNotIn        []string `json:"normalizedNameNotIn,omitempty"`
	NormalizedNameGT           *string  `json:"normalizedNameGT,omitempty"`
	NormalizedNameGTE          *string  `json:"normalizedNameGTE,omitempty"`
	NormalizedNameLT           *string  `json:"normalizedNameLT,omitempty"`
	NormalizedNameLTE          *string  `json:"normalizedNameLTE,omitempty"`
	NormalizedNameContains     *string  `json:"normalizedNameContains,omitempty"`
	NormalizedNameHasPrefix    *string  `json:"normalizedNameHasPrefix,omitempty"`
	NormalizedNameHasSuffix    *string  `json:"normalizedNameHasSuffix,omitempty"`
	NormalizedNameEqualFold    *string  `json:"normalizedNameEqualFold,omitempty"`
	NormalizedNameContainsFold *string  `json:"normalizedNameContainsFold,omitempty"`

	// "set_key" field predicates.
	SetKey             *string  `json:"setKey,omitempty"`
	SetKeyNEQ          *string  `json:"setKeyNEQ,omitempty"`
	SetKeyIn           []string `json:"setKeyIn,omitempty"`
	SetKeyNotIn        []string `json:"setKeyNotIn,omitempty"`
	SetKeyGT           *string  `json:"setKeyGT,omitempty"`
	SetKeyGTE          *string  `json:"setKeyGTE,omitempty"`
	SetKeyLT           *string  `json:"setKeyLT,omitempty"`
	SetKeyLTE          *string  `json:"setKeyLTE,omitempty"`
	SetKeyContains     *string  `json:"setKeyContains,omitempty"`
	SetKeyHasPrefix    *string  `json:"setKeyHasPrefix,omitempty"`
	SetKeyHasSuffix    *string  `json:"setKeyHasSuffix,omitempty"`
	SetKeyIsNil        bool     `json:"setKeyIsNil,omitempty"`
	SetKeyNotNil       bool     `json:"setKeyNotNil,omitempty"`
	SetKeyEqualFold    *string  `json:"setKeyEqualFold,omitempty"`
	SetKeyContainsFold *string  `json:"setKeyContainsFold,omitempty"`

	// "checksum" field predicates.
	Checksum             *string  `json:"checksum,omitempty"`
	ChecksumNEQ          *string  `json:"checksumNEQ,omitempty"`
	ChecksumIn           []string `json:"checksumIn,omitempty"`
	ChecksumNotIn        []string `json:"checksumNotIn,omitempty"`
	ChecksumGT           *string  `json:"checksumGT,omitempty"`
	ChecksumGTE          *string  `json:"checksumGTE,omitempty"`
	ChecksumLT           *string  `json:"checksumLT,omitempty"`
	ChecksumLTE          *string  `json:"checksumLTE,omitempty"`
	ChecksumContains     *string  `json:"checksumContains,omitempty"`
	ChecksumHasPrefix    *string  `json:"checksumHasPrefix,omitempty"`
	ChecksumHasSuffix    *string  `json:"checksumHasSuffix,omitempty"`
	ChecksumEqualFold    *string  `json:"checksumEqualFold,omitempty"`
	ChecksumContainsFold *string  `json:"checksumContainsFold,omitempty"`

	// "size_bytes" field predicates.
	SizeBytes      *int64  `json:"sizeBytes,omitempty"`
	SizeBytesNEQ   *int64  `json:"sizeBytesNEQ,omitempty"`
	SizeBytesIn    []int64 `json:"sizeBytesIn,omitempty"`
	SizeBytesNotIn []int64 `json:"sizeBytesNotIn,omitempty"`
	SizeBytesGT    *int64  `json:"sizeBytesGT,omitempty"`
	SizeBytesGTE   *int64  `json:"sizeBytesGTE,omitempty"`
	SizeBytesLT    *int64  `json:"sizeBytesLT,omitempty"`
	SizeBytesLTE   *int64  `json:"sizeBytesLTE,omitempty"`

	// "mime_type" field predicates.
	MimeType             *string  `json:"mimeType,omitempty"`
	MimeTypeNEQ          *string  `json:"mimeTypeNEQ,omitempty"`
	MimeTypeIn           []string `json:"mimeTypeIn,omitempty"`
	MimeTypeNotIn        []string `json:"mimeTypeNotIn,omitempty"`
	MimeTypeGT           *string  `json:"mimeTypeGT,omitempty"`
	MimeTypeGTE          *string  `json:"mimeTypeGTE,omitempty"`
	MimeTypeLT           *string  `json:"mimeTypeLT,omitempty"`
	MimeTypeLTE          *string  `json:"mimeTypeLTE,omitempty"`
	MimeTypeContains     *string  `json:"mimeTypeContains,omitempty"`
	MimeTypeHasPrefix    *string  `json:"mimeTypeHasPrefix,omitempty"`
	MimeTypeHasSuffix    *string  `json:"mimeTypeHasSuffix,omitempty"`
	MimeTypeIsNil        bool     `json:"mimeTypeIsNil,omitempty"`
	MimeTypeNotNil       bool     `json:"mimeTypeNotNil,omitempty"`
	MimeTypeEqualFold    *string  `json:"mimeTypeEqualFold,omitempty"`
	MimeTypeContainsFold *string  `json:"mimeTypeContainsFold,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatIsNil        bool     `json:"formatIsNil,omitempty"`
	FormatNotNil       bool     `json:"formatNotNil,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "quarantine" field predicates.
	Quarantine    *bool `json:"quarantine,omitempty"`
	QuarantineNEQ *bool `json:"quarantineNEQ,omitempty"`

	// "needs_review" field predicates.
	NeedsReview    *bool `json:"needsReview,omitempty"`
	NeedsReviewNEQ *bool `json:"needsReviewNEQ,omitempty"`

	// "disk_number" field predicates.
	DiskNumber       *int  `json:"diskNumber,omitempty"`
	DiskNumberNEQ    *int  `json:"diskNumberNEQ,omitempty"`
	DiskNumberIn     []int `json:"diskNumberIn,omitempty"`
	DiskNumberNotIn  []int `json:"diskNumberNotIn,omitempty"`
	DiskNumberGT     *int  `json:"diskNumberGT,omitempty"`
	DiskNumberGTE    *int  `json:"diskNumberGTE,omitempty"`
	DiskNumberLT     *int  `json:"diskNumberLT,omitempty"`
	DiskNumberLTE    *int  `json:"diskNumberLTE,omitempty"`
	DiskNumberIsNil  bool  `json:"diskNumberIsNil,omitempty"`
	DiskNumberNotNil bool  `json:"diskNumberNotNil,omitempty"`

	// "side" field predicates.
	Side             *string  `json:"side,omitempty"`
	SideNEQ          *string  `json:"sideNEQ,omitempty"`
	SideIn           []string `json:"sideIn,omitempty"`
	SideNotIn        []string `json:"sideNotIn,omitempty"`
	SideGT           *string  `json:"sideGT,omitempty"`
	SideGTE          *string  `json:"sideGTE,omitempty"`
	SideLT           *string  `json:"sideLT,omitempty"`
	SideLTE          *string  `json:"sideLTE,omitempty"`
	SideContains     *string  `json:"sideContains,omitempty"`
	SideHasPrefix    *string  `json:"sideHasPrefix,omitempty"`
	SideHasSuffix    *string  `json:"sideHasSuffix,omitempty"`
	SideIsNil        bool     `json:"sideIsNil,omitempty"`
	SideNotNil       bool     `json:"sideNotNil,omitempty"`
	SideEqualFold    *string  `json:"sideEqualFold,omitempty"`
	SideContainsFold *string  `json:"sideContainsFold,omitempty"`

	// "game" edge predicates.
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`

	// "group" edge predicates.
	HasGroup     *bool                  `json:"hasGroup,omitempty"`
	HasGroupWith []*FileGroupWhereInput `json:"hasGroupWith,omitempty"`

	// "comments" edge predicates.
	HasComments     *bool                `json:"hasComments,omitempty"`
	HasCommentsWith []*CommentWhereInput `json:"hasCommentsWith,omitempty"`

	// "reactions" edge predicates.
	HasReactions     *bool                     `json:"hasReactions,omitempty"`
	HasReactionsWith []*FileReactionWhereInput `json:"hasReactionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("ent: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, file.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, file.IDContainsFold(*i.IDContainsFold))
	}
	if i.Path != nil {
		predicates = append(predicates, file.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, file.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, file.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, file.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, file.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, file.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, file.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, file.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, file.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, file.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, file.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, file.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, file.PathContainsFold(*i.PathContainsFold))
	}
	if i.OriginalName != nil {
		predicates = append(predicates, file.OriginalNameEQ(*i.OriginalName))
	}
	if i.OriginalNameNEQ != nil {
		predicates = append(predicates, file.OriginalNameNEQ(*i.OriginalNameNEQ))
	}
	if len(i.OriginalNameIn) > 0 {
		predicates = append(predicates, file.OriginalNameIn(i.OriginalNameIn...))
	}
	if len(i.OriginalNameNotIn) > 0 {
		predicates = append(predicates, file.OriginalNameNotIn(i.OriginalNameNotIn...))
	}
	if i.OriginalNameGT != nil {
		predicates = append(predicates, file.OriginalNameGT(*i.OriginalNameGT))
	}
	if i.OriginalNameGTE != nil {
		predicates = append(predicates, file.OriginalNameGTE(*i.OriginalNameGTE))
	}
	if i.OriginalNameLT != nil {
		predicates = append(predicates, file.OriginalNameLT(*i.OriginalNameLT))
	}
	if i.OriginalNameLTE != nil {
		predicates = append(predicates, file.OriginalNameLTE(*i.OriginalNameLTE))
	}
	if i.OriginalNameContains != nil {
		predicates = append(predicates, file.OriginalNameContains(*i.OriginalNameContains))
	}
	if i.OriginalNameHasPrefix != nil {
		predicates = append(predicates, file.OriginalNameHasPrefix(*i.OriginalNameHasPrefix))
	}
	if i.OriginalNameHasSuffix != nil {
		predicates = append(predicates, file.OriginalNameHasSuffix(*i.OriginalNameHasSuffix))
	}
	if i.OriginalNameEqualFold != nil {
		predicates = append(predicates, file.OriginalNameEqualFold(*i.OriginalNameEqualFold))
	}
	if i.OriginalNameContainsFold != nil {
		predicates = append(predicates, file.OriginalNameContainsFold(*i.OriginalNameContainsFold))
	}
	if i.NormalizedName != nil {
		predicates = append(predicates, file.NormalizedNameEQ(*i.NormalizedName))
	}
	if i.NormalizedNameNEQ != nil {
		predicates = append(predicates, file.NormalizedNameNEQ(*i.NormalizedNameNEQ))
	}
	if len(i.NormalizedNameIn) > 0 {
		predicates = append(predicates, file.NormalizedNameIn(i.NormalizedNameIn...))
	}
	if len(i.NormalizedNameNotIn) > 0 {
		predicates = append(predicates, file.NormalizedNameNotIn(i.NormalizedNameNotIn...))
	}
	if i.NormalizedNameGT != nil {
		predicates = append(predicates, file.NormalizedNameGT(*i.NormalizedNameGT))
	}
	if i.NormalizedNameGTE != nil {
		predicates = append(predicates, file.NormalizedNameGTE(*i.NormalizedNameGTE))
	}
	if i.NormalizedNameLT != nil {
		predicates = append(predicates, file.NormalizedNameLT(*i.NormalizedNameLT))
	}
	if i.NormalizedNameLTE != nil {
		predicates = append(predicates, file.NormalizedNameLTE(*i.NormalizedNameLTE))
	}
	if i.NormalizedNameContains != nil {
		predicates = append(predicates, file.NormalizedNameContains(*i.NormalizedNameContains))
	}
	if i.NormalizedNameHasPrefix != nil {
		predicates = append(predicates, file.NormalizedNameHasPrefix(*i.NormalizedNameHasPrefix))
	}
	if i.NormalizedNameHasSuffix != nil {
		predicates = append(predicates, file.NormalizedNameHasSuffix(*i.NormalizedNameHasSuffix))
	}
	if i.NormalizedNameEqualFold != nil {
		predicates = append(predicates, file.NormalizedNameEqualFold(*i.NormalizedNameEqualFold))
	}
	if i.NormalizedNameContainsFold != nil {
		predicates = append(predicates, file.NormalizedNameContainsFold(*i.NormalizedNameContainsFold))
	}
	if i.SetKey != nil {
		predicates = append(predicates, file.SetKeyEQ(*i.SetKey))
	}
	if i.SetKeyNEQ != nil {
		predicates = append(predicates, file.SetKeyNEQ(*i.SetKeyNEQ))
	}
	if len(i.SetKeyIn) > 0 {
		predicates = append(predicates, file.SetKeyIn(i.SetKeyIn...))
	}
	if len(i.SetKeyNotIn) > 0 {
		predicates = append(predicates, file.SetKeyNotIn(i.SetKeyNotIn...))
	}
	if i.SetKeyGT != nil {
		predicates = append(predicates, file.SetKeyGT(*i.SetKeyGT))
	}
	if i.SetKeyGTE != nil {
		predicates = append(predicates, file.SetKeyGTE(*i.SetKeyGTE))
	}
	if i.SetKeyLT != nil {
		predicates = append(predicates, file.SetKeyLT(*i.SetKeyLT))
	}
	if i.SetKeyLTE != nil {
		predicates = append(predicates, file.SetKeyLTE(*i.SetKeyLTE))
	}
	if i.SetKeyContains != nil {
		predicates = append(predicates, file.SetKeyContains(*i.SetKeyContains))
	}
	if i.SetKeyHasPrefix != nil {
		predicates = append(predicates, file.SetKeyHasPrefix(*i.SetKeyHasPrefix))
	}
	if i.SetKeyHasSuffix != nil {
		predicates = append(predicates, file.SetKeyHasSuffix(*i.SetKeyHasSuffix))
	}
	if i.SetKeyIsNil {
		predicates = append(predicates, file.SetKeyIsNil())
	}
	if i.SetKeyNotNil {
		predicates = append(predicates, file.SetKeyNotNil())
	}
	if i.SetKeyEqualFold != nil {
		predicates = append(predicates, file.SetKeyEqualFold(*i.SetKeyEqualFold))
	}
	if i.SetKeyContainsFold != nil {
		predicates = append(predicates, file.SetKeyContainsFold(*i.SetKeyContainsFold))
	}
	if i.Checksum != nil {
		predicates = append(predicates, file.ChecksumEQ(*i.Checksum))
	}
	if i.ChecksumNEQ != nil {
		predicates = append(predicates, file.ChecksumNEQ(*i.ChecksumNEQ))
	}
	if len(i.ChecksumIn) > 0 {
		predicates = append(predicates, file.ChecksumIn(i.ChecksumIn...))
	}
	if len(i.ChecksumNotIn) > 0 {
		predicates = append(predicates, file.ChecksumNotIn(i.ChecksumNotIn...))
	}
	if i.ChecksumGT != nil {
		predicates = append(predicates, file.ChecksumGT(*i.ChecksumGT))
	}
	if i.ChecksumGTE != nil {
		predicates = append(predicates, file.ChecksumGTE(*i.ChecksumGTE))
	}
	if i.ChecksumLT != nil {
		predicates = append(predicates, file.ChecksumLT(*i.ChecksumLT))
	}
	if i.ChecksumLTE != nil {
		predicates = append(predicates, file.ChecksumLTE(*i.ChecksumLTE))
	}
	if i.ChecksumContains != nil {
		predicates = append(predicates, file.ChecksumContains(*i.ChecksumContains))
	}
	if i.ChecksumHasPrefix != nil {
		predicates = append(predicates, file.ChecksumHasPrefix(*i.ChecksumHasPrefix))
	}
	if i.ChecksumHasSuffix != nil {
		predicates = append(predicates, file.ChecksumHasSuffix(*i.ChecksumHasSuffix))
	}
	if i.ChecksumEqualFold != nil {
		predicates = append(predicates, file.ChecksumEqualFold(*i.ChecksumEqualFold))
	}
	if i.ChecksumContainsFold != nil {
		predicates = append(predicates, file.ChecksumContainsFold(*i.ChecksumContainsFold))
	}
	if i.SizeBytes != nil {
		predicates = append(predicates, file.SizeBytesEQ(*i.SizeBytes))
	}
	if i.SizeBytesNEQ != nil {
		predicates = append(predicates, file.SizeBytesNEQ(*i.SizeBytesNEQ))
	}
	if len(i.SizeBytesIn) > 0 {
		predicates = append(predicates, file.SizeBytesIn(i.SizeBytesIn...))
	}
	if len(i.SizeBytesNotIn) > 0 {
		predicates = append(predicates, file.SizeBytesNotIn(i.SizeBytesNotIn...))
	}
	if i.SizeBytesGT != nil {
		predicates = append(predicates, file.SizeBytesGT(*i.SizeBytesGT))
	}
	if i.SizeBytesGTE != nil {
		predicates = append(predicates, file.SizeBytesGTE(*i.SizeBytesGTE))
	}
	if i.SizeBytesLT != nil {
		predicates = append(predicates, file.SizeBytesLT(*i.SizeBytesLT))
	}
	if i.SizeBytesLTE != nil {
		predicates = append(predicates, file.SizeBytesLTE(*i.SizeBytesLTE))
	}
	if i.MimeType != nil {
		predicates = append(predicates, file.MimeTypeEQ(*i.MimeType))
	}
	if i.MimeTypeNEQ != nil {
		predicates = append(predicates, file.MimeTypeNEQ(*i.MimeTypeNEQ))
	}
	if len(i.MimeTypeIn) > 0 {
		predicates = append(predicates, file.MimeTypeIn(i.MimeTypeIn...))
	}
	if len(i.MimeTypeNotIn) > 0 {
		predicates = append(predicates, file.MimeTypeNotIn(i.MimeTypeNotIn...))
	}
	if i.MimeTypeGT != nil {
		predicates = append(predicates, file.MimeTypeGT(*i.MimeTypeGT))
	}
	if i.MimeTypeGTE != nil {
		predicates = append(predicates, file.MimeTypeGTE(*i.MimeTypeGTE))
	}
	if i.MimeTypeLT != nil {
		predicates = append(predicates, file.MimeTypeLT(*i.MimeTypeLT))
	}
	if i.MimeTypeLTE != nil {
		predicates = append(predicates, file.MimeTypeLTE(*i.MimeTypeLTE))
	}
	if i.MimeTypeContains != nil {
		predicates = append(predicates, file.MimeTypeContains(*i.MimeTypeContains))
	}
	if i.MimeTypeHasPrefix != nil {
		predicates = append(predicates, file.MimeTypeHasPrefix(*i.MimeTypeHasPrefix))
	}
	if i.MimeTypeHasSuffix != nil {
		predicates = append(predicates, file.MimeTypeHasSuffix(*i.MimeTypeHasSuffix))
	}
	if i.MimeTypeIsNil {
		predicates = append(predicates, file.MimeTypeIsNil())
	}
	if i.MimeTypeNotNil {
		predicates = append(predicates, file.MimeTypeNotNil())
	}
	if i.MimeTypeEqualFold != nil {
		predicates = append(predicates, file.MimeTypeEqualFold(*i.MimeTypeEqualFold))
	}
	if i.MimeTypeContainsFold != nil {
		predicates = append(predicates, file.MimeTypeContainsFold(*i.MimeTypeContainsFold))
	}
	if i.Format != nil {
		predicates = append(predicates, file.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, file.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, file.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, file.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, file.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, file.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, file.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, file.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, file.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, file.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, file.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatIsNil {
		predicates = append(predicates, file.FormatIsNil())
	}
	if i.FormatNotNil {
		predicates = append(predicates, file.FormatNotNil())
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, file.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, file.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.Source != nil {
		predicates = append(predicates, file.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, file.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, file.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, file.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, file.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, file.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, file.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, file.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, file.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, file.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, file.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, file.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, file.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.Quarantine != nil {
		predicates = append(predicates, file.QuarantineEQ(*i.Quarantine))
	}
	if i.QuarantineNEQ != nil {
		predicates = append(predicates, file.QuarantineNEQ(*i.QuarantineNEQ))
	}
	if i.NeedsReview != nil {
		predicates = append(predicates, file.NeedsReviewEQ(*i.NeedsReview))
	}
	if i.NeedsReviewNEQ != nil {
		predicates = append(predicates, file.NeedsReviewNEQ(*i.NeedsReviewNEQ))
	}
	if i.DiskNumber != nil {
		predicates = append(predicates, file.DiskNumberEQ(*i.DiskNumber))
	}
	if i.DiskNumberNEQ != nil {
		predicates = append(predicates, file.DiskNumberNEQ(*i.DiskNumberNEQ))
	}
	if len(i.DiskNumberIn) > 0 {
		predicates = append(predicates, file.DiskNumberIn(i.DiskNumberIn...))
	}
	if len(i.DiskNumberNotIn) > 0 {
		predicates = append(predicates, file.DiskNumberNotIn(i.DiskNumberNotIn...))
	}
	if i.DiskNumberGT != nil {
		predicates = append(predicates, file.DiskNumberGT(*i.DiskNumberGT))
	}
	if i.DiskNumberGTE != nil {
		predicates = append(predicates, file.DiskNumberGTE(*i.DiskNumberGTE))
	}
	if i.DiskNumberLT != nil {
		predicates = append(predicates, file.DiskNumberLT(*i.DiskNumberLT))
	}
	if i.DiskNumberLTE != nil {
		predicates = append(predicates, file.DiskNumberLTE(*i.DiskNumberLTE))
	}
	if i.DiskNumberIsNil {
		predicates = append(predicates, file.DiskNumberIsNil())
	}
	if i.DiskNumberNotNil {
		predicates = append(predicates, file.DiskNumberNotNil())
	}
	if i.Side != nil {
		predicates = append(predicates, file.SideEQ(*i.Side))
	}
	if i.SideNEQ != nil {
		predicates = append(predicates, file.SideNEQ(*i.SideNEQ))
	}
	if len(i.SideIn) > 0 {
		predicates = append(predicates, file.SideIn(i.SideIn...))
	}
	if len(i.SideNotIn) > 0 {
		predicates = append(predicates, file.SideNotIn(i.SideNotIn...))
	}
	if i.SideGT != nil {
		predicates = append(predicates, file.SideGT(*i.SideGT))
	}
	if i.SideGTE != nil {
		predicates = append(predicates, file.SideGTE(*i.SideGTE))
	}
	if i.SideLT != nil {
		predicates = append(predicates, file.SideLT(*i.SideLT))
	}
	if i.SideLTE != nil {
		predicates = append(predicates, file.SideLTE(*i.SideLTE))
	}
	if i.SideContains != nil {
		predicates = append(predicates, file.SideContains(*i.SideContains))
	}
	if i.SideHasPrefix != nil {
		predicates = append(predicates, file.SideHasPrefix(*i.SideHasPrefix))
	}
	if i.SideHasSuffix != nil {
		predicates = append(predicates, file.SideHasSuffix(*i.SideHasSuffix))
	}
	if i.SideIsNil {
		predicates = append(predicates, file.SideIsNil())
	}
	if i.SideNotNil {
		predicates = append(predicates, file.SideNotNil())
	}
	if i.SideEqualFold != nil {
		predicates = append(predicates, file.SideEqualFold(*i.SideEqualFold))
	}
	if i.SideContainsFold != nil {
		predicates = append(predicates, file.SideContainsFold(*i.SideContainsFold))
	}

	if i.HasGame != nil {
		p := file.HasGame()
		if !*i.HasGame {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGameWith) > 0 {
		with := make([]predicate.Game, 0, len(i.HasGameWith))
		for _, w := range i.HasGameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasGameWith(with...))
	}
	if i.HasGroup != nil {
		p := file.HasGroup()
		if !*i.HasGroup {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupWith) > 0 {
		with := make([]predicate.FileGroup, 0, len(i.HasGroupWith))
		for _, w := range i.HasGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasGroupWith(with...))
	}
	if i.HasComments != nil {
		p := file.HasComments()
		if !*i.HasComments {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommentsWith) > 0 {
		with := make([]predicate.Comment, 0, len(i.HasCommentsWith))
		for _, w := range i.HasCommentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCommentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasCommentsWith(with...))
	}
	if i.HasReactions != nil {
		p := file.HasReactions()
		if !*i.HasReactions {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReactionsWith) > 0 {
		with := make([]predicate.FileReaction, 0, len(i.HasReactionsWith))
		for _, w := range i.HasReactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasReactionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// FileGroupWhereInput represents a where input for filtering FileGroup queries.
type FileGroupWhereInput struct {
	Predicates []predicate.FileGroup  `json:"-"`
	Not        *FileGroupWhereInput   `json:"not,omitempty"`
	Or         []*FileGroupWhereInput `json:"or,omitempty"`
	And        []*FileGroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "game" edge predicates.
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileGroupWhereInput) AddPredicates(predicates ...predicate.FileGroup) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileGroupWhereInput filter on the FileGroupQuery builder.
func (i *FileGroupWhereInput) Filter(q *FileGroupQuery) (*FileGroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileGroupWhereInput is returned in case the FileGroupWhereInput is empty.
var ErrEmptyFileGroupWhereInput = errors.New("ent: empty predicate FileGroupWhereInput")

// P returns a predicate for filtering filegroups.
// An error is returned if the input is empty or invalid.
func (i *FileGroupWhereInput) P() (predicate.FileGroup, error) {
	var predicates []predicate.FileGroup
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, filegroup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.FileGroup, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, filegroup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.FileGroup, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, filegroup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, filegroup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, filegroup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, filegroup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, filegroup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, filegroup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, filegroup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, filegroup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, filegroup.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, filegroup.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, filegroup.IDContainsFold(*i.IDContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, filegroup.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, filegroup.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, filegroup.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, filegroup.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, filegroup.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, filegroup.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, filegroup.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, filegroup.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, filegroup.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, filegroup.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, filegroup.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, filegroup.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, filegroup.KeyContainsFold(*i.KeyContainsFold))
	}

	if i.HasFiles != nil {
		p := filegroup.HasFiles()
		if !*i.HasFiles {
			p = filegroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, filegroup.HasFilesWith(with...))
	}
	if i.HasGame != nil {
		p := filegroup.HasGame()
		if !*i.HasGame {
			p = filegroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGameWith) > 0 {
		with := make([]predicate.Game, 0, len(i.HasGameWith))
		for _, w := range i.HasGameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, filegroup.HasGameWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return filegroup.And(predicates...), nil
	}
}

// FileReactionWhereInput represents a where input for filtering FileReaction queries.
type FileReactionWhereInput struct {
	Predicates []predicate.FileReaction  `json:"-"`
	Not        *FileReactionWhereInput   `json:"not,omitempty"`
	Or         []*FileReactionWhereInput `json:"or,omitempty"`
	And        []*FileReactionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "value" field predicates.
	Value      *int  `json:"value,omitempty"`
	ValueNEQ   *int  `json:"valueNEQ,omitempty"`
	ValueIn    []int `json:"valueIn,omitempty"`
	ValueNotIn []int `json:"valueNotIn,omitempty"`
	ValueGT    *int  `json:"valueGT,omitempty"`
	ValueGTE   *int  `json:"valueGTE,omitempty"`
	ValueLT    *int  `json:"valueLT,omitempty"`
	ValueLTE   *int  `json:"valueLTE,omitempty"`

	// "file" edge predicates.
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileReactionWhereInput) AddPredicates(predicates ...predicate.FileReaction) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileReactionWhereInput filter on the FileReactionQuery builder.
func (i *FileReactionWhereInput) Filter(q *FileReactionQuery) (*FileReactionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileReactionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileReactionWhereInput is returned in case the FileReactionWhereInput is empty.
var ErrEmptyFileReactionWhereInput = errors.New("ent: empty predicate FileReactionWhereInput")

// P returns a predicate for filtering filereactions.
// An error is returned if the input is empty or invalid.
func (i *FileReactionWhereInput) P() (predicate.FileReaction, error) {
	var predicates []predicate.FileReaction
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, filereaction.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.FileReaction, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, filereaction.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.FileReaction, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, filereaction.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, filereaction.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, filereaction.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, filereaction.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, filereaction.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, filereaction.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, filereaction.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, filereaction.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, filereaction.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, filereaction.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, filereaction.IDContainsFold(*i.IDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, filereaction.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, filereaction.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, filereaction.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, filereaction.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, filereaction.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, filereaction.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, filereaction.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, filereaction.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, filereaction.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, filereaction.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, filereaction.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, filereaction.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, filereaction.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, filereaction.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, filereaction.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, filereaction.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, filereaction.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, filereaction.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, filereaction.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, filereaction.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, filereaction.ValueLTE(*i.ValueLTE))
	}

	if i.HasFile != nil {
		p := filereaction.HasFile()
		if !*i.HasFile {
			p = filereaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFileWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFileWith))
		for _, w := range i.HasFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, filereaction.HasFileWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileReactionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return filereaction.And(predicates...), nil
	}
}

// GameWhereInput represents a where input for filtering Game queries.
type GameWhereInput struct {
	Predicates []predicate.Game  `json:"-"`
	Not        *GameWhereInput   `json:"not,omitempty"`
	Or         []*GameWhereInput `json:"or,omitempty"`
	And        []*GameWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "platform" field predicates.
	Platform      *game.Platform  `json:"platform,omitempty"`
	PlatformNEQ   *game.Platform  `json:"platformNEQ,omitempty"`
	PlatformIn    []game.Platform `json:"platformIn,omitempty"`
	PlatformNotIn []game.Platform `json:"platformNotIn,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "year" field predicates.
	Year       *int  `json:"year,omitempty"`
	YearNEQ    *int  `json:"yearNEQ,omitempty"`
	YearIn     []int `json:"yearIn,omitempty"`
	YearNotIn  []int `json:"yearNotIn,omitempty"`
	YearGT     *int  `json:"yearGT,omitempty"`
	YearGTE    *int  `json:"yearGTE,omitempty"`
	YearLT     *int  `json:"yearLT,omitempty"`
	YearLTE    *int  `json:"yearLTE,omitempty"`
	YearIsNil  bool  `json:"yearIsNil,omitempty"`
	YearNotNil bool  `json:"yearNotNil,omitempty"`

	// "publisher" field predicates.
	Publisher             *string  `json:"publisher,omitempty"`
	PublisherNEQ          *string  `json:"publisherNEQ,omitempty"`
	PublisherIn           []string `json:"publisherIn,omitempty"`
	PublisherNotIn        []string `json:"publisherNotIn,omitempty"`
	PublisherGT           *string  `json:"publisherGT,omitempty"`
	PublisherGTE          *string  `json:"publisherGTE,omitempty"`
	PublisherLT           *string  `json:"publisherLT,omitempty"`
	PublisherLTE          *string  `json:"publisherLTE,omitempty"`
	PublisherContains     *string  `json:"publisherContains,omitempty"`
	PublisherHasPrefix    *string  `json:"publisherHasPrefix,omitempty"`
	PublisherHasSuffix    *string  `json:"publisherHasSuffix,omitempty"`
	PublisherIsNil        bool     `json:"publisherIsNil,omitempty"`
	PublisherNotNil       bool     `json:"publisherNotNil,omitempty"`
	PublisherEqualFold    *string  `json:"publisherEqualFold,omitempty"`
	PublisherContainsFold *string  `json:"publisherContainsFold,omitempty"`

	// "developer" field predicates.
	Developer             *string  `json:"developer,omitempty"`
	DeveloperNEQ          *string  `json:"developerNEQ,omitempty"`
	DeveloperIn           []string `json:"developerIn,omitempty"`
	DeveloperNotIn        []string `json:"developerNotIn,omitempty"`
	DeveloperGT           *string  `json:"developerGT,omitempty"`
	DeveloperGTE          *string  `json:"developerGTE,omitempty"`
	DeveloperLT           *string  `json:"developerLT,omitempty"`
	DeveloperLTE          *string  `json:"developerLTE,omitempty"`
	DeveloperContains     *string  `json:"developerContains,omitempty"`
	DeveloperHasPrefix    *string  `json:"developerHasPrefix,omitempty"`
	DeveloperHasSuffix    *string  `json:"developerHasSuffix,omitempty"`
	DeveloperIsNil        bool     `json:"developerIsNil,omitempty"`
	DeveloperNotNil       bool     `json:"developerNotNil,omitempty"`
	DeveloperEqualFold    *string  `json:"developerEqualFold,omitempty"`
	DeveloperContainsFold *string  `json:"developerContainsFold,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`

	// "images" edge predicates.
	HasImages     *bool              `json:"hasImages,omitempty"`
	HasImagesWith []*ImageWhereInput `json:"hasImagesWith,omitempty"`

	// "comments" edge predicates.
	HasComments     *bool                `json:"hasComments,omitempty"`
	HasCommentsWith []*CommentWhereInput `json:"hasCommentsWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool                  `json:"hasGroups,omitempty"`
	HasGroupsWith []*FileGroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "likes" edge predicates.
	HasLikes     *bool                 `json:"hasLikes,omitempty"`
	HasLikesWith []*GameLikeWhereInput `json:"hasLikesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GameWhereInput) AddPredicates(predicates ...predicate.Game) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GameWhereInput filter on the GameQuery builder.
func (i *GameWhereInput) Filter(q *GameQuery) (*GameQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGameWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGameWhereInput is returned in case the GameWhereInput is empty.
var ErrEmptyGameWhereInput = errors.New("ent: empty predicate GameWhereInput")

// P returns a predicate for filtering games.
// An error is returned if the input is empty or invalid.
func (i *GameWhereInput) P() (predicate.Game, error) {
	var predicates []predicate.Game
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, game.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Game, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, game.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Game, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, game.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, game.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, game.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, game.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, game.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, game.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, game.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, game.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, game.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, game.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, game.IDContainsFold(*i.IDContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, game.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, game.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, game.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, game.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, game.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, game.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, game.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, game.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, game.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, game.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, game.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, game.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, game.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Platform != nil {
		predicates = append(predicates, game.PlatformEQ(*i.Platform))
	}
	if i.PlatformNEQ != nil {
		predicates = append(predicates, game.PlatformNEQ(*i.PlatformNEQ))
	}
	if len(i.PlatformIn) > 0 {
		predicates = append(predicates, game.PlatformIn(i.PlatformIn...))
	}
	if len(i.PlatformNotIn) > 0 {
		predicates = append(predicates, game.PlatformNotIn(i.PlatformNotIn...))
	}
	if i.Title != nil {
		predicates = append(predicates, game.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, game.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, game.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, game.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, game.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, game.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, game.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, game.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, game.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, game.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, game.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, game.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, game.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Year != nil {
		predicates = append(predicates, game.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, game.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, game.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, game.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, game.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, game.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, game.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, game.YearLTE(*i.YearLTE))
	}
	if i.YearIsNil {
		predicates = append(predicates, game.YearIsNil())
	}
	if i.YearNotNil {
		predicates = append(predicates, game.YearNotNil())
	}
	if i.Publisher != nil {
		predicates = append(predicates, game.PublisherEQ(*i.Publisher))
	}
	if i.PublisherNEQ != nil {
		predicates = append(predicates, game.PublisherNEQ(*i.PublisherNEQ))
	}
	if len(i.PublisherIn) > 0 {
		predicates = append(predicates, game.PublisherIn(i.PublisherIn...))
	}
	if len(i.PublisherNotIn) > 0 {
		predicates = append(predicates, game.PublisherNotIn(i.PublisherNotIn...))
	}
	if i.PublisherGT != nil {
		predicates = append(predicates, game.PublisherGT(*i.PublisherGT))
	}
	if i.PublisherGTE != nil {
		predicates = append(predicates, game.PublisherGTE(*i.PublisherGTE))
	}
	if i.PublisherLT != nil {
		predicates = append(predicates, game.PublisherLT(*i.PublisherLT))
	}
	if i.PublisherLTE != nil {
		predicates = append(predicates, game.PublisherLTE(*i.PublisherLTE))
	}
	if i.PublisherContains != nil {
		predicates = append(predicates, game.PublisherContains(*i.PublisherContains))
	}
	if i.PublisherHasPrefix != nil {
		predicates = append(predicates, game.PublisherHasPrefix(*i.PublisherHasPrefix))
	}
	if i.PublisherHasSuffix != nil {
		predicates = append(predicates, game.PublisherHasSuffix(*i.PublisherHasSuffix))
	}
	if i.PublisherIsNil {
		predicates = append(predicates, game.PublisherIsNil())
	}
	if i.PublisherNotNil {
		predicates = append(predicates, game.PublisherNotNil())
	}
	if i.PublisherEqualFold != nil {
		predicates = append(predicates, game.PublisherEqualFold(*i.PublisherEqualFold))
	}
	if i.PublisherContainsFold != nil {
		predicates = append(predicates, game.PublisherContainsFold(*i.PublisherContainsFold))
	}
	if i.Developer != nil {
		predicates = append(predicates, game.DeveloperEQ(*i.Developer))
	}
	if i.DeveloperNEQ != nil {
		predicates = append(predicates, game.DeveloperNEQ(*i.DeveloperNEQ))
	}
	if len(i.DeveloperIn) > 0 {
		predicates = append(predicates, game.DeveloperIn(i.DeveloperIn...))
	}
	if len(i.DeveloperNotIn) > 0 {
		predicates = append(predicates, game.DeveloperNotIn(i.DeveloperNotIn...))
	}
	if i.DeveloperGT != nil {
		predicates = append(predicates, game.DeveloperGT(*i.DeveloperGT))
	}
	if i.DeveloperGTE != nil {
		predicates = append(predicates, game.DeveloperGTE(*i.DeveloperGTE))
	}
	if i.DeveloperLT != nil {
		predicates = append(predicates, game.DeveloperLT(*i.DeveloperLT))
	}
	if i.DeveloperLTE != nil {
		predicates = append(predicates, game.DeveloperLTE(*i.DeveloperLTE))
	}
	if i.DeveloperContains != nil {
		predicates = append(predicates, game.DeveloperContains(*i.DeveloperContains))
	}
	if i.DeveloperHasPrefix != nil {
		predicates = append(predicates, game.DeveloperHasPrefix(*i.DeveloperHasPrefix))
	}
	if i.DeveloperHasSuffix != nil {
		predicates = append(predicates, game.DeveloperHasSuffix(*i.DeveloperHasSuffix))
	}
	if i.DeveloperIsNil {
		predicates = append(predicates, game.DeveloperIsNil())
	}
	if i.DeveloperNotNil {
		predicates = append(predicates, game.DeveloperNotNil())
	}
	if i.DeveloperEqualFold != nil {
		predicates = append(predicates, game.DeveloperEqualFold(*i.DeveloperEqualFold))
	}
	if i.DeveloperContainsFold != nil {
		predicates = append(predicates, game.DeveloperContainsFold(*i.DeveloperContainsFold))
	}

	if i.HasFiles != nil {
		p := game.HasFiles()
		if !*i.HasFiles {
			p = game.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, game.HasFilesWith(with...))
	}
	if i.HasImages != nil {
		p := game.HasImages()
		if !*i.HasImages {
			p = game.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImagesWith) > 0 {
		with := make([]predicate.Image, 0, len(i.HasImagesWith))
		for _, w := range i.HasImagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasImagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, game.HasImagesWith(with...))
	}
	if i.HasComments != nil {
		p := game.HasComments()
		if !*i.HasComments {
			p = game.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommentsWith) > 0 {
		with := make([]predicate.Comment, 0, len(i.HasCommentsWith))
		for _, w := range i.HasCommentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCommentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, game.HasCommentsWith(with...))
	}
	if i.HasGroups != nil {
		p := game.HasGroups()
		if !*i.HasGroups {
			p = game.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.FileGroup, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, game.HasGroupsWith(with...))
	}
	if i.HasLikes != nil {
		p := game.HasLikes()
		if !*i.HasLikes {
			p = game.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLikesWith) > 0 {
		with := make([]predicate.GameLike, 0, len(i.HasLikesWith))
		for _, w := range i.HasLikesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLikesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, game.HasLikesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGameWhereInput
	case 1:
		return predicates[0], nil
	default:
		return game.And(predicates...), nil
	}
}

// GameLikeWhereInput represents a where input for filtering GameLike queries.
type GameLikeWhereInput struct {
	Predicates []predicate.GameLike  `json:"-"`
	Not        *GameLikeWhereInput   `json:"not,omitempty"`
	Or         []*GameLikeWhereInput `json:"or,omitempty"`
	And        []*GameLikeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "game" edge predicates.
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GameLikeWhereInput) AddPredicates(predicates ...predicate.GameLike) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GameLikeWhereInput filter on the GameLikeQuery builder.
func (i *GameLikeWhereInput) Filter(q *GameLikeQuery) (*GameLikeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGameLikeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGameLikeWhereInput is returned in case the GameLikeWhereInput is empty.
var ErrEmptyGameLikeWhereInput = errors.New("ent: empty predicate GameLikeWhereInput")

// P returns a predicate for filtering gamelikes.
// An error is returned if the input is empty or invalid.
func (i *GameLikeWhereInput) P() (predicate.GameLike, error) {
	var predicates []predicate.GameLike
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, gamelike.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GameLike, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, gamelike.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GameLike, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, gamelike.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, gamelike.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gamelike.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gamelike.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gamelike.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gamelike.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gamelike.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gamelike.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gamelike.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, gamelike.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, gamelike.IDContainsFold(*i.IDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, gamelike.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, gamelike.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, gamelike.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, gamelike.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, gamelike.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, gamelike.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, gamelike.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, gamelike.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, gamelike.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, gamelike.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, gamelike.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, gamelike.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, gamelike.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasGame != nil {
		p := gamelike.HasGame()
		if !*i.HasGame {
			p = gamelike.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGameWith) > 0 {
		with := make([]predicate.Game, 0, len(i.HasGameWith))
		for _, w := range i.HasGameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gamelike.HasGameWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGameLikeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return gamelike.And(predicates...), nil
	}
}

// ImageWhereInput represents a where input for filtering Image queries.
type ImageWhereInput struct {
	Predicates []predicate.Image  `json:"-"`
	Not        *ImageWhereInput   `json:"not,omitempty"`
	Or         []*ImageWhereInput `json:"or,omitempty"`
	And        []*ImageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *image.Kind  `json:"kind,omitempty"`
	KindNEQ   *image.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []image.Kind `json:"kindIn,omitempty"`
	KindNotIn []image.Kind `json:"kindNotIn,omitempty"`

	// "position" field predicates.
	Position      *int  `json:"position,omitempty"`
	PositionNEQ   *int  `json:"positionNEQ,omitempty"`
	PositionIn    []int `json:"positionIn,omitempty"`
	PositionNotIn []int `json:"positionNotIn,omitempty"`
	PositionGT    *int  `json:"positionGT,omitempty"`
	PositionGTE   *int  `json:"positionGTE,omitempty"`
	PositionLT    *int  `json:"positionLT,omitempty"`
	PositionLTE   *int  `json:"positionLTE,omitempty"`

	// "s3_key" field predicates.
	S3Key             *string  `json:"s3Key,omitempty"`
	S3KeyNEQ          *string  `json:"s3KeyNEQ,omitempty"`
	S3KeyIn           []string `json:"s3KeyIn,omitempty"`
	S3KeyNotIn        []string `json:"s3KeyNotIn,omitempty"`
	S3KeyGT           *string  `json:"s3KeyGT,omitempty"`
	S3KeyGTE          *string  `json:"s3KeyGTE,omitempty"`
	S3KeyLT           *string  `json:"s3KeyLT,omitempty"`
	S3KeyLTE          *string  `json:"s3KeyLTE,omitempty"`
	S3KeyContains     *string  `json:"s3KeyContains,omitempty"`
	S3KeyHasPrefix    *string  `json:"s3KeyHasPrefix,omitempty"`
	S3KeyHasSuffix    *string  `json:"s3KeyHasSuffix,omitempty"`
	S3KeyEqualFold    *string  `json:"s3KeyEqualFold,omitempty"`
	S3KeyContainsFold *string  `json:"s3KeyContainsFold,omitempty"`

	// "width" field predicates.
	Width      *int  `json:"width,omitempty"`
	WidthNEQ   *int  `json:"widthNEQ,omitempty"`
	WidthIn    []int `json:"widthIn,omitempty"`
	WidthNotIn []int `json:"widthNotIn,omitempty"`
	WidthGT    *int  `json:"widthGT,omitempty"`
	WidthGTE   *int  `json:"widthGTE,omitempty"`
	WidthLT    *int  `json:"widthLT,omitempty"`
	WidthLTE   *int  `json:"widthLTE,omitempty"`

	// "height" field predicates.
	Height      *int  `json:"height,omitempty"`
	HeightNEQ   *int  `json:"heightNEQ,omitempty"`
	HeightIn    []int `json:"heightIn,omitempty"`
	HeightNotIn []int `json:"heightNotIn,omitempty"`
	HeightGT    *int  `json:"heightGT,omitempty"`
	HeightGTE   *int  `json:"heightGTE,omitempty"`
	HeightLT    *int  `json:"heightLT,omitempty"`
	HeightLTE   *int  `json:"heightLTE,omitempty"`

	// "game" edge predicates.
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ImageWhereInput) AddPredicates(predicates ...predicate.Image) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ImageWhereInput filter on the ImageQuery builder.
func (i *ImageWhereInput) Filter(q *ImageQuery) (*ImageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyImageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyImageWhereInput is returned in case the ImageWhereInput is empty.
var ErrEmptyImageWhereInput = errors.New("ent: empty predicate ImageWhereInput")

// P returns a predicate for filtering images.
// An error is returned if the input is empty or invalid.
func (i *ImageWhereInput) P() (predicate.Image, error) {
	var predicates []predicate.Image
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, image.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Image, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, image.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Image, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, image.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, image.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, image.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, image.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, image.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, image.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, image.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, image.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, image.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, image.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, image.IDContainsFold(*i.IDContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, image.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, image.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, image.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, image.KindNotIn(i.KindNotIn...))
	}
	if i.Position != nil {
		predicates = append(predicates, image.PositionEQ(*i.Position))
	}
	if i.PositionNEQ != nil {
		predicates = append(predicates, image.PositionNEQ(*i.PositionNEQ))
	}
	if len(i.PositionIn) > 0 {
		predicates = append(predicates, image.PositionIn(i.PositionIn...))
	}
	if len(i.PositionNotIn) > 0 {
		predicates = append(predicates, image.PositionNotIn(i.PositionNotIn...))
	}
	if i.PositionGT != nil {
		predicates = append(predicates, image.PositionGT(*i.PositionGT))
	}
	if i.PositionGTE != nil {
		predicates = append(predicates, image.PositionGTE(*i.PositionGTE))
	}
	if i.PositionLT != nil {
		predicates = append(predicates, image.PositionLT(*i.PositionLT))
	}
	if i.PositionLTE != nil {
		predicates = append(predicates, image.PositionLTE(*i.PositionLTE))
	}
	if i.S3Key != nil {
		predicates = append(predicates, image.S3KeyEQ(*i.S3Key))
	}
	if i.S3KeyNEQ != nil {
		predicates = append(predicates, image.S3KeyNEQ(*i.S3KeyNEQ))
	}
	if len(i.S3KeyIn) > 0 {
		predicates = append(predicates, image.S3KeyIn(i.S3KeyIn...))
	}
	if len(i.S3KeyNotIn) > 0 {
		predicates = append(predicates, image.S3KeyNotIn(i.S3KeyNotIn...))
	}
	if i.S3KeyGT != nil {
		predicates = append(predicates, image.S3KeyGT(*i.S3KeyGT))
	}
	if i.S3KeyGTE != nil {
		predicates = append(predicates, image.S3KeyGTE(*i.S3KeyGTE))
	}
	if i.S3KeyLT != nil {
		predicates = append(predicates, image.S3KeyLT(*i.S3KeyLT))
	}
	if i.S3KeyLTE != nil {
		predicates = append(predicates, image.S3KeyLTE(*i.S3KeyLTE))
	}
	if i.S3KeyContains != nil {
		predicates = append(predicates, image.S3KeyContains(*i.S3KeyContains))
	}
	if i.S3KeyHasPrefix != nil {
		predicates = append(predicates, image.S3KeyHasPrefix(*i.S3KeyHasPrefix))
	}
	if i.S3KeyHasSuffix != nil {
		predicates = append(predicates, image.S3KeyHasSuffix(*i.S3KeyHasSuffix))
	}
	if i.S3KeyEqualFold != nil {
		predicates = append(predicates, image.S3KeyEqualFold(*i.S3KeyEqualFold))
	}
	if i.S3KeyContainsFold != nil {
		predicates = append(predicates, image.S3KeyContainsFold(*i.S3KeyContainsFold))
	}
	if i.Width != nil {
		predicates = append(predicates, image.WidthEQ(*i.Width))
	}
	if i.WidthNEQ != nil {
		predicates = append(predicates, image.WidthNEQ(*i.WidthNEQ))
	}
	if len(i.WidthIn) > 0 {
		predicates = append(predicates, image.WidthIn(i.WidthIn...))
	}
	if len(i.WidthNotIn) > 0 {
		predicates = append(predicates, image.WidthNotIn(i.WidthNotIn...))
	}
	if i.WidthGT != nil {
		predicates = append(predicates, image.WidthGT(*i.WidthGT))
	}
	if i.WidthGTE != nil {
		predicates = append(predicates, image.WidthGTE(*i.WidthGTE))
	}
	if i.WidthLT != nil {
		predicates = append(predicates, image.WidthLT(*i.WidthLT))
	}
	if i.WidthLTE != nil {
		predicates = append(predicates, image.WidthLTE(*i.WidthLTE))
	}
	if i.Height != nil {
		predicates = append(predicates, image.HeightEQ(*i.Height))
	}
	if i.HeightNEQ != nil {
		predicates = append(predicates, image.HeightNEQ(*i.HeightNEQ))
	}
	if len(i.HeightIn) > 0 {
		predicates = append(predicates, image.HeightIn(i.HeightIn...))
	}
	if len(i.HeightNotIn) > 0 {
		predicates = append(predicates, image.HeightNotIn(i.HeightNotIn...))
	}
	if i.HeightGT != nil {
		predicates = append(predicates, image.HeightGT(*i.HeightGT))
	}
	if i.HeightGTE != nil {
		predicates = append(predicates, image.HeightGTE(*i.HeightGTE))
	}
	if i.HeightLT != nil {
		predicates = append(predicates, image.HeightLT(*i.HeightLT))
	}
	if i.HeightLTE != nil {
		predicates = append(predicates, image.HeightLTE(*i.HeightLTE))
	}

	if i.HasGame != nil {
		p := image.HasGame()
		if !*i.HasGame {
			p = image.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGameWith) > 0 {
		with := make([]predicate.Game, 0, len(i.HasGameWith))
		for _, w := range i.HasGameWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGameWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, image.HasGameWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyImageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return image.And(predicates...), nil
	}
}

// ReportWhereInput represents a where input for filtering Report queries.
type ReportWhereInput struct {
	Predicates []predicate.Report  `json:"-"`
	Not        *ReportWhereInput   `json:"not,omitempty"`
	Or         []*ReportWhereInput `json:"or,omitempty"`
	And        []*ReportWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "subject_type" field predicates.
	SubjectType             *string  `json:"subjectType,omitempty"`
	SubjectTypeNEQ          *string  `json:"subjectTypeNEQ,omitempty"`
	SubjectTypeIn           []string `json:"subjectTypeIn,omitempty"`
	SubjectTypeNotIn        []string `json:"subjectTypeNotIn,omitempty"`
	SubjectTypeGT           *string  `json:"subjectTypeGT,omitempty"`
	SubjectTypeGTE          *string  `json:"subjectTypeGTE,omitempty"`
	SubjectTypeLT           *string  `json:"subjectTypeLT,omitempty"`
	SubjectTypeLTE          *string  `json:"subjectTypeLTE,omitempty"`
	SubjectTypeContains     *string  `json:"subjectTypeContains,omitempty"`
	SubjectTypeHasPrefix    *string  `json:"subjectTypeHasPrefix,omitempty"`
	SubjectTypeHasSuffix    *string  `json:"subjectTypeHasSuffix,omitempty"`
	SubjectTypeEqualFold    *string  `json:"subjectTypeEqualFold,omitempty"`
	SubjectTypeContainsFold *string  `json:"subjectTypeContainsFold,omitempty"`

	// "subject_id" field predicates.
	SubjectID             *string  `json:"subjectID,omitempty"`
	SubjectIDNEQ          *string  `json:"subjectIDNEQ,omitempty"`
	SubjectIDIn           []string `json:"subjectIDIn,omitempty"`
	SubjectIDNotIn        []string `json:"subjectIDNotIn,omitempty"`
	SubjectIDGT           *string  `json:"subjectIDGT,omitempty"`
	SubjectIDGTE          *string  `json:"subjectIDGTE,omitempty"`
	SubjectIDLT           *string  `json:"subjectIDLT,omitempty"`
	SubjectIDLTE          *string  `json:"subjectIDLTE,omitempty"`
	SubjectIDContains     *string  `json:"subjectIDContains,omitempty"`
	SubjectIDHasPrefix    *string  `json:"subjectIDHasPrefix,omitempty"`
	SubjectIDHasSuffix    *string  `json:"subjectIDHasSuffix,omitempty"`
	SubjectIDEqualFold    *string  `json:"subjectIDEqualFold,omitempty"`
	SubjectIDContainsFold *string  `json:"subjectIDContainsFold,omitempty"`

	// "reporter_id" field predicates.
	ReporterID             *string  `json:"reporterID,omitempty"`
	ReporterIDNEQ          *string  `json:"reporterIDNEQ,omitempty"`
	ReporterIDIn           []string `json:"reporterIDIn,omitempty"`
	ReporterIDNotIn        []string `json:"reporterIDNotIn,omitempty"`
	ReporterIDGT           *string  `json:"reporterIDGT,omitempty"`
	ReporterIDGTE          *string  `json:"reporterIDGTE,omitempty"`
	ReporterIDLT           *string  `json:"reporterIDLT,omitempty"`
	ReporterIDLTE          *string  `json:"reporterIDLTE,omitempty"`
	ReporterIDContains     *string  `json:"reporterIDContains,omitempty"`
	ReporterIDHasPrefix    *string  `json:"reporterIDHasPrefix,omitempty"`
	ReporterIDHasSuffix    *string  `json:"reporterIDHasSuffix,omitempty"`
	ReporterIDIsNil        bool     `json:"reporterIDIsNil,omitempty"`
	ReporterIDNotNil       bool     `json:"reporterIDNotNil,omitempty"`
	ReporterIDEqualFold    *string  `json:"reporterIDEqualFold,omitempty"`
	ReporterIDContainsFold *string  `json:"reporterIDContainsFold,omitempty"`

	// "reason" field predicates.
	Reason             *string  `json:"reason,omitempty"`
	ReasonNEQ          *string  `json:"reasonNEQ,omitempty"`
	ReasonIn           []string `json:"reasonIn,omitempty"`
	ReasonNotIn        []string `json:"reasonNotIn,omitempty"`
	ReasonGT           *string  `json:"reasonGT,omitempty"`
	ReasonGTE          *string  `json:"reasonGTE,omitempty"`
	ReasonLT           *string  `json:"reasonLT,omitempty"`
	ReasonLTE          *string  `json:"reasonLTE,omitempty"`
	ReasonContains     *string  `json:"reasonContains,omitempty"`
	ReasonHasPrefix    *string  `json:"reasonHasPrefix,omitempty"`
	ReasonHasSuffix    *string  `json:"reasonHasSuffix,omitempty"`
	ReasonEqualFold    *string  `json:"reasonEqualFold,omitempty"`
	ReasonContainsFold *string  `json:"reasonContainsFold,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "status" field predicates.
	Status      *report.Status  `json:"status,omitempty"`
	StatusNEQ   *report.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []report.Status `json:"statusIn,omitempty"`
	StatusNotIn []report.Status `json:"statusNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReportWhereInput) AddPredicates(predicates ...predicate.Report) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReportWhereInput filter on the ReportQuery builder.
func (i *ReportWhereInput) Filter(q *ReportQuery) (*ReportQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReportWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReportWhereInput is returned in case the ReportWhereInput is empty.
var ErrEmptyReportWhereInput = errors.New("ent: empty predicate ReportWhereInput")

// P returns a predicate for filtering reports.
// An error is returned if the input is empty or invalid.
func (i *ReportWhereInput) P() (predicate.Report, error) {
	var predicates []predicate.Report
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, report.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Report, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, report.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Report, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, report.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, report.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, report.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, report.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, report.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, report.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, report.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, report.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, report.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, report.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, report.IDContainsFold(*i.IDContainsFold))
	}
	if i.SubjectType != nil {
		predicates = append(predicates, report.SubjectTypeEQ(*i.SubjectType))
	}
	if i.SubjectTypeNEQ != nil {
		predicates = append(predicates, report.SubjectTypeNEQ(*i.SubjectTypeNEQ))
	}
	if len(i.SubjectTypeIn) > 0 {
		predicates = append(predicates, report.SubjectTypeIn(i.SubjectTypeIn...))
	}
	if len(i.SubjectTypeNotIn) > 0 {
		predicates = append(predicates, report.SubjectTypeNotIn(i.SubjectTypeNotIn...))
	}
	if i.SubjectTypeGT != nil {
		predicates = append(predicates, report.SubjectTypeGT(*i.SubjectTypeGT))
	}
	if i.SubjectTypeGTE != nil {
		predicates = append(predicates, report.SubjectTypeGTE(*i.SubjectTypeGTE))
	}
	if i.SubjectTypeLT != nil {
		predicates = append(predicates, report.SubjectTypeLT(*i.SubjectTypeLT))
	}
	if i.SubjectTypeLTE != nil {
		predicates = append(predicates, report.SubjectTypeLTE(*i.SubjectTypeLTE))
	}
	if i.SubjectTypeContains != nil {
		predicates = append(predicates, report.SubjectTypeContains(*i.SubjectTypeContains))
	}
	if i.SubjectTypeHasPrefix != nil {
		predicates = append(predicates, report.SubjectTypeHasPrefix(*i.SubjectTypeHasPrefix))
	}
	if i.SubjectTypeHasSuffix != nil {
		predicates = append(predicates, report.SubjectTypeHasSuffix(*i.SubjectTypeHasSuffix))
	}
	if i.SubjectTypeEqualFold != nil {
		predicates = append(predicates, report.SubjectTypeEqualFold(*i.SubjectTypeEqualFold))
	}
	if i.SubjectTypeContainsFold != nil {
		predicates = append(predicates, report.SubjectTypeContainsFold(*i.SubjectTypeContainsFold))
	}
	if i.SubjectID != nil {
		predicates = append(predicates, report.SubjectIDEQ(*i.SubjectID))
	}
	if i.SubjectIDNEQ != nil {
		predicates = append(predicates, report.SubjectIDNEQ(*i.SubjectIDNEQ))
	}
	if len(i.SubjectIDIn) > 0 {
		predicates = append(predicates, report.SubjectIDIn(i.SubjectIDIn...))
	}
	if len(i.SubjectIDNotIn) > 0 {
		predicates = append(predicates, report.SubjectIDNotIn(i.SubjectIDNotIn...))
	}
	if i.SubjectIDGT != nil {
		predicates = append(predicates, report.SubjectIDGT(*i.SubjectIDGT))
	}
	if i.SubjectIDGTE != nil {
		predicates = append(predicates, report.SubjectIDGTE(*i.SubjectIDGTE))
	}
	if i.SubjectIDLT != nil {
		predicates = append(predicates, report.SubjectIDLT(*i.SubjectIDLT))
	}
	if i.SubjectIDLTE != nil {
		predicates = append(predicates, report.SubjectIDLTE(*i.SubjectIDLTE))
	}
	if i.SubjectIDContains != nil {
		predicates = append(predicates, report.SubjectIDContains(*i.SubjectIDContains))
	}
	if i.SubjectIDHasPrefix != nil {
		predicates = append(predicates, report.SubjectIDHasPrefix(*i.SubjectIDHasPrefix))
	}
	if i.SubjectIDHasSuffix != nil {
		predicates = append(predicates, report.SubjectIDHasSuffix(*i.SubjectIDHasSuffix))
	}
	if i.SubjectIDEqualFold != nil {
		predicates = append(predicates, report.SubjectIDEqualFold(*i.SubjectIDEqualFold))
	}
	if i.SubjectIDContainsFold != nil {
		predicates = append(predicates, report.SubjectIDContainsFold(*i.SubjectIDContainsFold))
	}
	if i.ReporterID != nil {
		predicates = append(predicates, report.ReporterIDEQ(*i.ReporterID))
	}
	if i.ReporterIDNEQ != nil {
		predicates = append(predicates, report.ReporterIDNEQ(*i.ReporterIDNEQ))
	}
	if len(i.ReporterIDIn) > 0 {
		predicates = append(predicates, report.ReporterIDIn(i.ReporterIDIn...))
	}
	if len(i.ReporterIDNotIn) > 0 {
		predicates = append(predicates, report.ReporterIDNotIn(i.ReporterIDNotIn...))
	}
	if i.ReporterIDGT != nil {
		predicates = append(predicates, report.ReporterIDGT(*i.ReporterIDGT))
	}
	if i.ReporterIDGTE != nil {
		predicates = append(predicates, report.ReporterIDGTE(*i.ReporterIDGTE))
	}
	if i.ReporterIDLT != nil {
		predicates = append(predicates, report.ReporterIDLT(*i.ReporterIDLT))
	}
	if i.ReporterIDLTE != nil {
		predicates = append(predicates, report.ReporterIDLTE(*i.ReporterIDLTE))
	}
	if i.ReporterIDContains != nil {
		predicates = append(predicates, report.ReporterIDContains(*i.ReporterIDContains))
	}
	if i.ReporterIDHasPrefix != nil {
		predicates = append(predicates, report.ReporterIDHasPrefix(*i.ReporterIDHasPrefix))
	}
	if i.ReporterIDHasSuffix != nil {
		predicates = append(predicates, report.ReporterIDHasSuffix(*i.ReporterIDHasSuffix))
	}
	if i.ReporterIDIsNil {
		predicates = append(predicates, report.ReporterIDIsNil())
	}
	if i.ReporterIDNotNil {
		predicates = append(predicates, report.ReporterIDNotNil())
	}
	if i.ReporterIDEqualFold != nil {
		predicates = append(predicates, report.ReporterIDEqualFold(*i.ReporterIDEqualFold))
	}
	if i.ReporterIDContainsFold != nil {
		predicates = append(predicates, report.ReporterIDContainsFold(*i.ReporterIDContainsFold))
	}
	if i.Reason != nil {
		predicates = append(predicates, report.ReasonEQ(*i.Reason))
	}
	if i.ReasonNEQ != nil {
		predicates = append(predicates, report.ReasonNEQ(*i.ReasonNEQ))
	}
	if len(i.ReasonIn) > 0 {
		predicates = append(predicates, report.ReasonIn(i.ReasonIn...))
	}
	if len(i.ReasonNotIn) > 0 {
		predicates = append(predicates, report.ReasonNotIn(i.ReasonNotIn...))
	}
	if i.ReasonGT != nil {
		predicates = append(predicates, report.ReasonGT(*i.ReasonGT))
	}
	if i.ReasonGTE != nil {
		predicates = append(predicates, report.ReasonGTE(*i.ReasonGTE))
	}
	if i.ReasonLT != nil {
		predicates = append(predicates, report.ReasonLT(*i.ReasonLT))
	}
	if i.ReasonLTE != nil {
		predicates = append(predicates, report.ReasonLTE(*i.ReasonLTE))
	}
	if i.ReasonContains != nil {
		predicates = append(predicates, report.ReasonContains(*i.ReasonContains))
	}
	if i.ReasonHasPrefix != nil {
		predicates = append(predicates, report.ReasonHasPrefix(*i.ReasonHasPrefix))
	}
	if i.ReasonHasSuffix != nil {
		predicates = append(predicates, report.ReasonHasSuffix(*i.ReasonHasSuffix))
	}
	if i.ReasonEqualFold != nil {
		predicates = append(predicates, report.ReasonEqualFold(*i.ReasonEqualFold))
	}
	if i.ReasonContainsFold != nil {
		predicates = append(predicates, report.ReasonContainsFold(*i.ReasonContainsFold))
	}
	if i.Note != nil {
		predicates = append(predicates, report.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, report.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, report.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, report.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, report.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, report.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, report.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, report.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, report.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, report.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, report.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, report.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, report.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, report.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, report.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, report.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, report.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, report.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, report.StatusNotIn(i.StatusNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReportWhereInput
	case 1:
		return predicates[0], nil
	default:
		return report.And(predicates...), nil
	}
}

// SiteSettingWhereInput represents a where input for filtering SiteSetting queries.
type SiteSettingWhereInput struct {
	Predicates []predicate.SiteSetting  `json:"-"`
	Not        *SiteSettingWhereInput   `json:"not,omitempty"`
	Or         []*SiteSettingWhereInput `json:"or,omitempty"`
	And        []*SiteSettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "public" field predicates.
	Public    *bool `json:"public,omitempty"`
	PublicNEQ *bool `json:"publicNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SiteSettingWhereInput) AddPredicates(predicates ...predicate.SiteSetting) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SiteSettingWhereInput filter on the SiteSettingQuery builder.
func (i *SiteSettingWhereInput) Filter(q *SiteSettingQuery) (*SiteSettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySiteSettingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySiteSettingWhereInput is returned in case the SiteSettingWhereInput is empty.
var ErrEmptySiteSettingWhereInput = errors.New("ent: empty predicate SiteSettingWhereInput")

// P returns a predicate for filtering sitesettings.
// An error is returned if the input is empty or invalid.
func (i *SiteSettingWhereInput) P() (predicate.SiteSetting, error) {
	var predicates []predicate.SiteSetting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, sitesetting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SiteSetting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, sitesetting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SiteSetting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, sitesetting.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, sitesetting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, sitesetting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, sitesetting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, sitesetting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, sitesetting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, sitesetting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, sitesetting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, sitesetting.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, sitesetting.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, sitesetting.IDContainsFold(*i.IDContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, sitesetting.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, sitesetting.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, sitesetting.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, sitesetting.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, sitesetting.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, sitesetting.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, sitesetting.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, sitesetting.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, sitesetting.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, sitesetting.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, sitesetting.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, sitesetting.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, sitesetting.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Public != nil {
		predicates = append(predicates, sitesetting.PublicEQ(*i.Public))
	}
	if i.PublicNEQ != nil {
		predicates = append(predicates, sitesetting.PublicNEQ(*i.PublicNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySiteSettingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return sitesetting.And(predicates...), nil
	}
}

// UserShadowWhereInput represents a where input for filtering UserShadow queries.
type UserShadowWhereInput struct {
	Predicates []predicate.UserShadow  `json:"-"`
	Not        *UserShadowWhereInput   `json:"not,omitempty"`
	Or         []*UserShadowWhereInput `json:"or,omitempty"`
	And        []*UserShadowWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "keycloak_sub" field predicates.
	KeycloakSub             *string  `json:"keycloakSub,omitempty"`
	KeycloakSubNEQ          *string  `json:"keycloakSubNEQ,omitempty"`
	KeycloakSubIn           []string `json:"keycloakSubIn,omitempty"`
	KeycloakSubNotIn        []string `json:"keycloakSubNotIn,omitempty"`
	KeycloakSubGT           *string  `json:"keycloakSubGT,omitempty"`
	KeycloakSubGTE          *string  `json:"keycloakSubGTE,omitempty"`
	KeycloakSubLT           *string  `json:"keycloakSubLT,omitempty"`
	KeycloakSubLTE          *string  `json:"keycloakSubLTE,omitempty"`
	KeycloakSubContains     *string  `json:"keycloakSubContains,omitempty"`
	KeycloakSubHasPrefix    *string  `json:"keycloakSubHasPrefix,omitempty"`
	KeycloakSubHasSuffix    *string  `json:"keycloakSubHasSuffix,omitempty"`
	KeycloakSubEqualFold    *string  `json:"keycloakSubEqualFold,omitempty"`
	KeycloakSubContainsFold *string  `json:"keycloakSubContainsFold,omitempty"`

	// "handle" field predicates.
	Handle             *string  `json:"handle,omitempty"`
	HandleNEQ          *string  `json:"handleNEQ,omitempty"`
	HandleIn           []string `json:"handleIn,omitempty"`
	HandleNotIn        []string `json:"handleNotIn,omitempty"`
	HandleGT           *string  `json:"handleGT,omitempty"`
	HandleGTE          *string  `json:"handleGTE,omitempty"`
	HandleLT           *string  `json:"handleLT,omitempty"`
	HandleLTE          *string  `json:"handleLTE,omitempty"`
	HandleContains     *string  `json:"handleContains,omitempty"`
	HandleHasPrefix    *string  `json:"handleHasPrefix,omitempty"`
	HandleHasSuffix    *string  `json:"handleHasSuffix,omitempty"`
	HandleIsNil        bool     `json:"handleIsNil,omitempty"`
	HandleNotNil       bool     `json:"handleNotNil,omitempty"`
	HandleEqualFold    *string  `json:"handleEqualFold,omitempty"`
	HandleContainsFold *string  `json:"handleContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserShadowWhereInput) AddPredicates(predicates ...predicate.UserShadow) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserShadowWhereInput filter on the UserShadowQuery builder.
func (i *UserShadowWhereInput) Filter(q *UserShadowQuery) (*UserShadowQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserShadowWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserShadowWhereInput is returned in case the UserShadowWhereInput is empty.
var ErrEmptyUserShadowWhereInput = errors.New("ent: empty predicate UserShadowWhereInput")

// P returns a predicate for filtering usershadows.
// An error is returned if the input is empty or invalid.
func (i *UserShadowWhereInput) P() (predicate.UserShadow, error) {
	var predicates []predicate.UserShadow
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usershadow.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserShadow, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usershadow.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserShadow, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usershadow.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usershadow.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usershadow.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usershadow.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usershadow.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usershadow.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usershadow.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usershadow.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usershadow.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, usershadow.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, usershadow.IDContainsFold(*i.IDContainsFold))
	}
	if i.KeycloakSub != nil {
		predicates = append(predicates, usershadow.KeycloakSubEQ(*i.KeycloakSub))
	}
	if i.KeycloakSubNEQ != nil {
		predicates = append(predicates, usershadow.KeycloakSubNEQ(*i.KeycloakSubNEQ))
	}
	if len(i.KeycloakSubIn) > 0 {
		predicates = append(predicates, usershadow.KeycloakSubIn(i.KeycloakSubIn...))
	}
	if len(i.KeycloakSubNotIn) > 0 {
		predicates = append(predicates, usershadow.KeycloakSubNotIn(i.KeycloakSubNotIn...))
	}
	if i.KeycloakSubGT != nil {
		predicates = append(predicates, usershadow.KeycloakSubGT(*i.KeycloakSubGT))
	}
	if i.KeycloakSubGTE != nil {
		predicates = append(predicates, usershadow.KeycloakSubGTE(*i.KeycloakSubGTE))
	}
	if i.KeycloakSubLT != nil {
		predicates = append(predicates, usershadow.KeycloakSubLT(*i.KeycloakSubLT))
	}
	if i.KeycloakSubLTE != nil {
		predicates = append(predicates, usershadow.KeycloakSubLTE(*i.KeycloakSubLTE))
	}
	if i.KeycloakSubContains != nil {
		predicates = append(predicates, usershadow.KeycloakSubContains(*i.KeycloakSubContains))
	}
	if i.KeycloakSubHasPrefix != nil {
		predicates = append(predicates, usershadow.KeycloakSubHasPrefix(*i.KeycloakSubHasPrefix))
	}
	if i.KeycloakSubHasSuffix != nil {
		predicates = append(predicates, usershadow.KeycloakSubHasSuffix(*i.KeycloakSubHasSuffix))
	}
	if i.KeycloakSubEqualFold != nil {
		predicates = append(predicates, usershadow.KeycloakSubEqualFold(*i.KeycloakSubEqualFold))
	}
	if i.KeycloakSubContainsFold != nil {
		predicates = append(predicates, usershadow.KeycloakSubContainsFold(*i.KeycloakSubContainsFold))
	}
	if i.Handle != nil {
		predicates = append(predicates, usershadow.HandleEQ(*i.Handle))
	}
	if i.HandleNEQ != nil {
		predicates = append(predicates, usershadow.HandleNEQ(*i.HandleNEQ))
	}
	if len(i.HandleIn) > 0 {
		predicates = append(predicates, usershadow.HandleIn(i.HandleIn...))
	}
	if len(i.HandleNotIn) > 0 {
		predicates = append(predicates, usershadow.HandleNotIn(i.HandleNotIn...))
	}
	if i.HandleGT != nil {
		predicates = append(predicates, usershadow.HandleGT(*i.HandleGT))
	}
	if i.HandleGTE != nil {
		predicates = append(predicates, usershadow.HandleGTE(*i.HandleGTE))
	}
	if i.HandleLT != nil {
		predicates = append(predicates, usershadow.HandleLT(*i.HandleLT))
	}
	if i.HandleLTE != nil {
		predicates = append(predicates, usershadow.HandleLTE(*i.HandleLTE))
	}
	if i.HandleContains != nil {
		predicates = append(predicates, usershadow.HandleContains(*i.HandleContains))
	}
	if i.HandleHasPrefix != nil {
		predicates = append(predicates, usershadow.HandleHasPrefix(*i.HandleHasPrefix))
	}
	if i.HandleHasSuffix != nil {
		predicates = append(predicates, usershadow.HandleHasSuffix(*i.HandleHasSuffix))
	}
	if i.HandleIsNil {
		predicates = append(predicates, usershadow.HandleIsNil())
	}
	if i.HandleNotNil {
		predicates = append(predicates, usershadow.HandleNotNil())
	}
	if i.HandleEqualFold != nil {
		predicates = append(predicates, usershadow.HandleEqualFold(*i.HandleEqualFold))
	}
	if i.HandleContainsFold != nil {
		predicates = append(predicates, usershadow.HandleContainsFold(*i.HandleContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, usershadow.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, usershadow.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, usershadow.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, usershadow.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, usershadow.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, usershadow.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, usershadow.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, usershadow.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, usershadow.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, usershadow.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, usershadow.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, usershadow.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, usershadow.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, usershadow.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, usershadow.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserShadowWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usershadow.And(predicates...), nil
	}
}
