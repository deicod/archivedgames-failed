// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/deicod/archivedgames/ent/comment"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/filegroup"
	"github.com/deicod/archivedgames/ent/filereaction"
	"github.com/deicod/archivedgames/ent/game"
	"github.com/deicod/archivedgames/ent/gamelike"
	"github.com/deicod/archivedgames/ent/image"
	"github.com/deicod/archivedgames/ent/predicate"
	"github.com/deicod/archivedgames/ent/report"
	"github.com/deicod/archivedgames/ent/sitesetting"
	"github.com/deicod/archivedgames/ent/usershadow"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComment      = "Comment"
	TypeFile         = "File"
	TypeFileGroup    = "FileGroup"
	TypeFileReaction = "FileReaction"
	TypeGame         = "Game"
	TypeGameLike     = "GameLike"
	TypeImage        = "Image"
	TypeReport       = "Report"
	TypeSiteSetting  = "SiteSetting"
	TypeUserShadow   = "UserShadow"
)

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	subject_type  *string
	subject_id    *string
	user_id       *string
	language      *string
	content       *string
	created_at    *time.Time
	edited_at     *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	game          *string
	clearedgame   bool
	file          *string
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id string) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubjectType sets the "subject_type" field.
func (m *CommentMutation) SetSubjectType(s string) {
	m.subject_type = &s
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *CommentMutation) SubjectType() (r string, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldSubjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *CommentMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *CommentMutation) SetSubjectID(s string) {
	m.subject_id = &s
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *CommentMutation) SubjectID() (r string, exists bool) {
	v := m.subject_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldSubjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *CommentMutation) ResetSubjectID() {
	m.subject_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
}

// SetLanguage sets the "language" field.
func (m *CommentMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *CommentMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *CommentMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[comment.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *CommentMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[comment.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *CommentMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, comment.FieldLanguage)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEditedAt sets the "edited_at" field.
func (m *CommentMutation) SetEditedAt(t time.Time) {
	m.edited_at = &t
}

// EditedAt returns the value of the "edited_at" field in the mutation.
func (m *CommentMutation) EditedAt() (r time.Time, exists bool) {
	v := m.edited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEditedAt returns the old "edited_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEditedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditedAt: %w", err)
	}
	return oldValue.EditedAt, nil
}

// ClearEditedAt clears the value of the "edited_at" field.
func (m *CommentMutation) ClearEditedAt() {
	m.edited_at = nil
	m.clearedFields[comment.FieldEditedAt] = struct{}{}
}

// EditedAtCleared returns if the "edited_at" field was cleared in this mutation.
func (m *CommentMutation) EditedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldEditedAt]
	return ok
}

// ResetEditedAt resets all changes to the "edited_at" field.
func (m *CommentMutation) ResetEditedAt() {
	m.edited_at = nil
	delete(m.clearedFields, comment.FieldEditedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[comment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, comment.FieldDeletedAt)
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *CommentMutation) SetGameID(id string) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *CommentMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *CommentMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *CommentMutation) GameID() (id string, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) GameIDs() (ids []string) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *CommentMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *CommentMutation) SetFileID(id string) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *CommentMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *CommentMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *CommentMutation) FileID() (id string, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) FileIDs() (ids []string) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *CommentMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.subject_type != nil {
		fields = append(fields, comment.FieldSubjectType)
	}
	if m.subject_id != nil {
		fields = append(fields, comment.FieldSubjectID)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.language != nil {
		fields = append(fields, comment.FieldLanguage)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.edited_at != nil {
		fields = append(fields, comment.FieldEditedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldSubjectType:
		return m.SubjectType()
	case comment.FieldSubjectID:
		return m.SubjectID()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldLanguage:
		return m.Language()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldEditedAt:
		return m.EditedAt()
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case comment.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldLanguage:
		return m.OldLanguage(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldEditedAt:
		return m.OldEditedAt(ctx)
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldSubjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case comment.FieldSubjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldEditedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldLanguage) {
		fields = append(fields, comment.FieldLanguage)
	}
	if m.FieldCleared(comment.FieldEditedAt) {
		fields = append(fields, comment.FieldEditedAt)
	}
	if m.FieldCleared(comment.FieldDeletedAt) {
		fields = append(fields, comment.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldLanguage:
		m.ClearLanguage()
		return nil
	case comment.FieldEditedAt:
		m.ClearEditedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case comment.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldLanguage:
		m.ResetLanguage()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldEditedAt:
		m.ResetEditedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.game != nil {
		edges = append(edges, comment.EdgeGame)
	}
	if m.file != nil {
		edges = append(edges, comment.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgame {
		edges = append(edges, comment.EdgeGame)
	}
	if m.clearedfile {
		edges = append(edges, comment.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeGame:
		return m.clearedgame
	case comment.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeGame:
		m.ClearGame()
		return nil
	case comment.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeGame:
		m.ResetGame()
		return nil
	case comment.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op               Op
	typ              string
	id               *string
	_path            *string
	original_name    *string
	normalized_name  *string
	set_key          *string
	checksum         *string
	size_bytes       *int64
	addsize_bytes    *int64
	mime_type        *string
	format           *string
	source           *string
	quarantine       *bool
	needs_review     *bool
	disk_number      *int
	adddisk_number   *int
	side             *string
	clearedFields    map[string]struct{}
	game             *string
	clearedgame      bool
	group            *string
	clearedgroup     bool
	comments         map[string]struct{}
	removedcomments  map[string]struct{}
	clearedcomments  bool
	reactions        map[string]struct{}
	removedreactions map[string]struct{}
	clearedreactions bool
	done             bool
	oldValue         func(context.Context) (*File, error)
	predicates       []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id string) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetOriginalName sets the "original_name" field.
func (m *FileMutation) SetOriginalName(s string) {
	m.original_name = &s
}

// OriginalName returns the value of the "original_name" field in the mutation.
func (m *FileMutation) OriginalName() (r string, exists bool) {
	v := m.original_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalName returns the old "original_name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOriginalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalName: %w", err)
	}
	return oldValue.OriginalName, nil
}

// ResetOriginalName resets all changes to the "original_name" field.
func (m *FileMutation) ResetOriginalName() {
	m.original_name = nil
}

// SetNormalizedName sets the "normalized_name" field.
func (m *FileMutation) SetNormalizedName(s string) {
	m.normalized_name = &s
}

// NormalizedName returns the value of the "normalized_name" field in the mutation.
func (m *FileMutation) NormalizedName() (r string, exists bool) {
	v := m.normalized_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalizedName returns the old "normalized_name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldNormalizedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalizedName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalizedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalizedName: %w", err)
	}
	return oldValue.NormalizedName, nil
}

// ResetNormalizedName resets all changes to the "normalized_name" field.
func (m *FileMutation) ResetNormalizedName() {
	m.normalized_name = nil
}

// SetSetKey sets the "set_key" field.
func (m *FileMutation) SetSetKey(s string) {
	m.set_key = &s
}

// SetKey returns the value of the "set_key" field in the mutation.
func (m *FileMutation) SetKey() (r string, exists bool) {
	v := m.set_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSetKey returns the old "set_key" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSetKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetKey: %w", err)
	}
	return oldValue.SetKey, nil
}

// ClearSetKey clears the value of the "set_key" field.
func (m *FileMutation) ClearSetKey() {
	m.set_key = nil
	m.clearedFields[file.FieldSetKey] = struct{}{}
}

// SetKeyCleared returns if the "set_key" field was cleared in this mutation.
func (m *FileMutation) SetKeyCleared() bool {
	_, ok := m.clearedFields[file.FieldSetKey]
	return ok
}

// ResetSetKey resets all changes to the "set_key" field.
func (m *FileMutation) ResetSetKey() {
	m.set_key = nil
	delete(m.clearedFields, file.FieldSetKey)
}

// SetChecksum sets the "checksum" field.
func (m *FileMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *FileMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *FileMutation) ResetChecksum() {
	m.checksum = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *FileMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *FileMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *FileMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *FileMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *FileMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
}

// SetMimeType sets the "mime_type" field.
func (m *FileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *FileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *FileMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[file.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *FileMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[file.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *FileMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, file.FieldMimeType)
}

// SetFormat sets the "format" field.
func (m *FileMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *FileMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ClearFormat clears the value of the "format" field.
func (m *FileMutation) ClearFormat() {
	m.format = nil
	m.clearedFields[file.FieldFormat] = struct{}{}
}

// FormatCleared returns if the "format" field was cleared in this mutation.
func (m *FileMutation) FormatCleared() bool {
	_, ok := m.clearedFields[file.FieldFormat]
	return ok
}

// ResetFormat resets all changes to the "format" field.
func (m *FileMutation) ResetFormat() {
	m.format = nil
	delete(m.clearedFields, file.FieldFormat)
}

// SetSource sets the "source" field.
func (m *FileMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FileMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FileMutation) ResetSource() {
	m.source = nil
}

// SetQuarantine sets the "quarantine" field.
func (m *FileMutation) SetQuarantine(b bool) {
	m.quarantine = &b
}

// Quarantine returns the value of the "quarantine" field in the mutation.
func (m *FileMutation) Quarantine() (r bool, exists bool) {
	v := m.quarantine
	if v == nil {
		return
	}
	return *v, true
}

// OldQuarantine returns the old "quarantine" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldQuarantine(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuarantine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuarantine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuarantine: %w", err)
	}
	return oldValue.Quarantine, nil
}

// ResetQuarantine resets all changes to the "quarantine" field.
func (m *FileMutation) ResetQuarantine() {
	m.quarantine = nil
}

// SetNeedsReview sets the "needs_review" field.
func (m *FileMutation) SetNeedsReview(b bool) {
	m.needs_review = &b
}

// NeedsReview returns the value of the "needs_review" field in the mutation.
func (m *FileMutation) NeedsReview() (r bool, exists bool) {
	v := m.needs_review
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedsReview returns the old "needs_review" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldNeedsReview(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedsReview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedsReview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedsReview: %w", err)
	}
	return oldValue.NeedsReview, nil
}

// ResetNeedsReview resets all changes to the "needs_review" field.
func (m *FileMutation) ResetNeedsReview() {
	m.needs_review = nil
}

// SetDiskNumber sets the "disk_number" field.
func (m *FileMutation) SetDiskNumber(i int) {
	m.disk_number = &i
	m.adddisk_number = nil
}

// DiskNumber returns the value of the "disk_number" field in the mutation.
func (m *FileMutation) DiskNumber() (r int, exists bool) {
	v := m.disk_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDiskNumber returns the old "disk_number" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDiskNumber(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiskNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiskNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiskNumber: %w", err)
	}
	return oldValue.DiskNumber, nil
}

// AddDiskNumber adds i to the "disk_number" field.
func (m *FileMutation) AddDiskNumber(i int) {
	if m.adddisk_number != nil {
		*m.adddisk_number += i
	} else {
		m.adddisk_number = &i
	}
}

// AddedDiskNumber returns the value that was added to the "disk_number" field in this mutation.
func (m *FileMutation) AddedDiskNumber() (r int, exists bool) {
	v := m.adddisk_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiskNumber clears the value of the "disk_number" field.
func (m *FileMutation) ClearDiskNumber() {
	m.disk_number = nil
	m.adddisk_number = nil
	m.clearedFields[file.FieldDiskNumber] = struct{}{}
}

// DiskNumberCleared returns if the "disk_number" field was cleared in this mutation.
func (m *FileMutation) DiskNumberCleared() bool {
	_, ok := m.clearedFields[file.FieldDiskNumber]
	return ok
}

// ResetDiskNumber resets all changes to the "disk_number" field.
func (m *FileMutation) ResetDiskNumber() {
	m.disk_number = nil
	m.adddisk_number = nil
	delete(m.clearedFields, file.FieldDiskNumber)
}

// SetSide sets the "side" field.
func (m *FileMutation) SetSide(s string) {
	m.side = &s
}

// Side returns the value of the "side" field in the mutation.
func (m *FileMutation) Side() (r string, exists bool) {
	v := m.side
	if v == nil {
		return
	}
	return *v, true
}

// OldSide returns the old "side" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSide(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSide: %w", err)
	}
	return oldValue.Side, nil
}

// ClearSide clears the value of the "side" field.
func (m *FileMutation) ClearSide() {
	m.side = nil
	m.clearedFields[file.FieldSide] = struct{}{}
}

// SideCleared returns if the "side" field was cleared in this mutation.
func (m *FileMutation) SideCleared() bool {
	_, ok := m.clearedFields[file.FieldSide]
	return ok
}

// ResetSide resets all changes to the "side" field.
func (m *FileMutation) ResetSide() {
	m.side = nil
	delete(m.clearedFields, file.FieldSide)
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *FileMutation) SetGameID(id string) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *FileMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *FileMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *FileMutation) GameID() (id string, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *FileMutation) GameIDs() (ids []string) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *FileMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// SetGroupID sets the "group" edge to the FileGroup entity by id.
func (m *FileMutation) SetGroupID(id string) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the FileGroup entity.
func (m *FileMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the FileGroup entity was cleared.
func (m *FileMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *FileMutation) GroupID() (id string, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *FileMutation) GroupIDs() (ids []string) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *FileMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *FileMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *FileMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *FileMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *FileMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *FileMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *FileMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *FileMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddReactionIDs adds the "reactions" edge to the FileReaction entity by ids.
func (m *FileMutation) AddReactionIDs(ids ...string) {
	if m.reactions == nil {
		m.reactions = make(map[string]struct{})
	}
	for i := range ids {
		m.reactions[ids[i]] = struct{}{}
	}
}

// ClearReactions clears the "reactions" edge to the FileReaction entity.
func (m *FileMutation) ClearReactions() {
	m.clearedreactions = true
}

// ReactionsCleared reports if the "reactions" edge to the FileReaction entity was cleared.
func (m *FileMutation) ReactionsCleared() bool {
	return m.clearedreactions
}

// RemoveReactionIDs removes the "reactions" edge to the FileReaction entity by IDs.
func (m *FileMutation) RemoveReactionIDs(ids ...string) {
	if m.removedreactions == nil {
		m.removedreactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reactions, ids[i])
		m.removedreactions[ids[i]] = struct{}{}
	}
}

// RemovedReactions returns the removed IDs of the "reactions" edge to the FileReaction entity.
func (m *FileMutation) RemovedReactionsIDs() (ids []string) {
	for id := range m.removedreactions {
		ids = append(ids, id)
	}
	return
}

// ReactionsIDs returns the "reactions" edge IDs in the mutation.
func (m *FileMutation) ReactionsIDs() (ids []string) {
	for id := range m.reactions {
		ids = append(ids, id)
	}
	return
}

// ResetReactions resets all changes to the "reactions" edge.
func (m *FileMutation) ResetReactions() {
	m.reactions = nil
	m.clearedreactions = false
	m.removedreactions = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.original_name != nil {
		fields = append(fields, file.FieldOriginalName)
	}
	if m.normalized_name != nil {
		fields = append(fields, file.FieldNormalizedName)
	}
	if m.set_key != nil {
		fields = append(fields, file.FieldSetKey)
	}
	if m.checksum != nil {
		fields = append(fields, file.FieldChecksum)
	}
	if m.size_bytes != nil {
		fields = append(fields, file.FieldSizeBytes)
	}
	if m.mime_type != nil {
		fields = append(fields, file.FieldMimeType)
	}
	if m.format != nil {
		fields = append(fields, file.FieldFormat)
	}
	if m.source != nil {
		fields = append(fields, file.FieldSource)
	}
	if m.quarantine != nil {
		fields = append(fields, file.FieldQuarantine)
	}
	if m.needs_review != nil {
		fields = append(fields, file.FieldNeedsReview)
	}
	if m.disk_number != nil {
		fields = append(fields, file.FieldDiskNumber)
	}
	if m.side != nil {
		fields = append(fields, file.FieldSide)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldPath:
		return m.Path()
	case file.FieldOriginalName:
		return m.OriginalName()
	case file.FieldNormalizedName:
		return m.NormalizedName()
	case file.FieldSetKey:
		return m.SetKey()
	case file.FieldChecksum:
		return m.Checksum()
	case file.FieldSizeBytes:
		return m.SizeBytes()
	case file.FieldMimeType:
		return m.MimeType()
	case file.FieldFormat:
		return m.Format()
	case file.FieldSource:
		return m.Source()
	case file.FieldQuarantine:
		return m.Quarantine()
	case file.FieldNeedsReview:
		return m.NeedsReview()
	case file.FieldDiskNumber:
		return m.DiskNumber()
	case file.FieldSide:
		return m.Side()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldOriginalName:
		return m.OldOriginalName(ctx)
	case file.FieldNormalizedName:
		return m.OldNormalizedName(ctx)
	case file.FieldSetKey:
		return m.OldSetKey(ctx)
	case file.FieldChecksum:
		return m.OldChecksum(ctx)
	case file.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case file.FieldMimeType:
		return m.OldMimeType(ctx)
	case file.FieldFormat:
		return m.OldFormat(ctx)
	case file.FieldSource:
		return m.OldSource(ctx)
	case file.FieldQuarantine:
		return m.OldQuarantine(ctx)
	case file.FieldNeedsReview:
		return m.OldNeedsReview(ctx)
	case file.FieldDiskNumber:
		return m.OldDiskNumber(ctx)
	case file.FieldSide:
		return m.OldSide(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldOriginalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalName(v)
		return nil
	case file.FieldNormalizedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalizedName(v)
		return nil
	case file.FieldSetKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetKey(v)
		return nil
	case file.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case file.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case file.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case file.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case file.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case file.FieldQuarantine:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuarantine(v)
		return nil
	case file.FieldNeedsReview:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedsReview(v)
		return nil
	case file.FieldDiskNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiskNumber(v)
		return nil
	case file.FieldSide:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSide(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, file.FieldSizeBytes)
	}
	if m.adddisk_number != nil {
		fields = append(fields, file.FieldDiskNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSizeBytes:
		return m.AddedSizeBytes()
	case file.FieldDiskNumber:
		return m.AddedDiskNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	case file.FieldDiskNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiskNumber(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldSetKey) {
		fields = append(fields, file.FieldSetKey)
	}
	if m.FieldCleared(file.FieldMimeType) {
		fields = append(fields, file.FieldMimeType)
	}
	if m.FieldCleared(file.FieldFormat) {
		fields = append(fields, file.FieldFormat)
	}
	if m.FieldCleared(file.FieldDiskNumber) {
		fields = append(fields, file.FieldDiskNumber)
	}
	if m.FieldCleared(file.FieldSide) {
		fields = append(fields, file.FieldSide)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldSetKey:
		m.ClearSetKey()
		return nil
	case file.FieldMimeType:
		m.ClearMimeType()
		return nil
	case file.FieldFormat:
		m.ClearFormat()
		return nil
	case file.FieldDiskNumber:
		m.ClearDiskNumber()
		return nil
	case file.FieldSide:
		m.ClearSide()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldOriginalName:
		m.ResetOriginalName()
		return nil
	case file.FieldNormalizedName:
		m.ResetNormalizedName()
		return nil
	case file.FieldSetKey:
		m.ResetSetKey()
		return nil
	case file.FieldChecksum:
		m.ResetChecksum()
		return nil
	case file.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case file.FieldMimeType:
		m.ResetMimeType()
		return nil
	case file.FieldFormat:
		m.ResetFormat()
		return nil
	case file.FieldSource:
		m.ResetSource()
		return nil
	case file.FieldQuarantine:
		m.ResetQuarantine()
		return nil
	case file.FieldNeedsReview:
		m.ResetNeedsReview()
		return nil
	case file.FieldDiskNumber:
		m.ResetDiskNumber()
		return nil
	case file.FieldSide:
		m.ResetSide()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.game != nil {
		edges = append(edges, file.EdgeGame)
	}
	if m.group != nil {
		edges = append(edges, file.EdgeGroup)
	}
	if m.comments != nil {
		edges = append(edges, file.EdgeComments)
	}
	if m.reactions != nil {
		edges = append(edges, file.EdgeReactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.reactions))
		for id := range m.reactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomments != nil {
		edges = append(edges, file.EdgeComments)
	}
	if m.removedreactions != nil {
		edges = append(edges, file.EdgeReactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.removedreactions))
		for id := range m.removedreactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgame {
		edges = append(edges, file.EdgeGame)
	}
	if m.clearedgroup {
		edges = append(edges, file.EdgeGroup)
	}
	if m.clearedcomments {
		edges = append(edges, file.EdgeComments)
	}
	if m.clearedreactions {
		edges = append(edges, file.EdgeReactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeGame:
		return m.clearedgame
	case file.EdgeGroup:
		return m.clearedgroup
	case file.EdgeComments:
		return m.clearedcomments
	case file.EdgeReactions:
		return m.clearedreactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeGame:
		m.ClearGame()
		return nil
	case file.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeGame:
		m.ResetGame()
		return nil
	case file.EdgeGroup:
		m.ResetGroup()
		return nil
	case file.EdgeComments:
		m.ResetComments()
		return nil
	case file.EdgeReactions:
		m.ResetReactions()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FileGroupMutation represents an operation that mutates the FileGroup nodes in the graph.
type FileGroupMutation struct {
	config
	op            Op
	typ           string
	id            *string
	key           *string
	clearedFields map[string]struct{}
	files         map[string]struct{}
	removedfiles  map[string]struct{}
	clearedfiles  bool
	game          *string
	clearedgame   bool
	done          bool
	oldValue      func(context.Context) (*FileGroup, error)
	predicates    []predicate.FileGroup
}

var _ ent.Mutation = (*FileGroupMutation)(nil)

// filegroupOption allows management of the mutation configuration using functional options.
type filegroupOption func(*FileGroupMutation)

// newFileGroupMutation creates new mutation for the FileGroup entity.
func newFileGroupMutation(c config, op Op, opts ...filegroupOption) *FileGroupMutation {
	m := &FileGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFileGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileGroupID sets the ID field of the mutation.
func withFileGroupID(id string) filegroupOption {
	return func(m *FileGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FileGroup
		)
		m.oldValue = func(ctx context.Context) (*FileGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileGroup sets the old FileGroup of the mutation.
func withFileGroup(node *FileGroup) filegroupOption {
	return func(m *FileGroupMutation) {
		m.oldValue = func(context.Context) (*FileGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileGroup entities.
func (m *FileGroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileGroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileGroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *FileGroupMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FileGroupMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the FileGroup entity.
// If the FileGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileGroupMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FileGroupMutation) ResetKey() {
	m.key = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *FileGroupMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *FileGroupMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *FileGroupMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *FileGroupMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *FileGroupMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *FileGroupMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *FileGroupMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *FileGroupMutation) SetGameID(id string) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *FileGroupMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *FileGroupMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *FileGroupMutation) GameID() (id string, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *FileGroupMutation) GameIDs() (ids []string) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *FileGroupMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// Where appends a list predicates to the FileGroupMutation builder.
func (m *FileGroupMutation) Where(ps ...predicate.FileGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileGroup).
func (m *FileGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileGroupMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.key != nil {
		fields = append(fields, filegroup.FieldKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filegroup.FieldKey:
		return m.Key()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filegroup.FieldKey:
		return m.OldKey(ctx)
	}
	return nil, fmt.Errorf("unknown FileGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filegroup.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	}
	return fmt.Errorf("unknown FileGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileGroupMutation) ResetField(name string) error {
	switch name {
	case filegroup.FieldKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown FileGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.files != nil {
		edges = append(edges, filegroup.EdgeFiles)
	}
	if m.game != nil {
		edges = append(edges, filegroup.EdgeGame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filegroup.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case filegroup.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfiles != nil {
		edges = append(edges, filegroup.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filegroup.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfiles {
		edges = append(edges, filegroup.EdgeFiles)
	}
	if m.clearedgame {
		edges = append(edges, filegroup.EdgeGame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case filegroup.EdgeFiles:
		return m.clearedfiles
	case filegroup.EdgeGame:
		return m.clearedgame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileGroupMutation) ClearEdge(name string) error {
	switch name {
	case filegroup.EdgeGame:
		m.ClearGame()
		return nil
	}
	return fmt.Errorf("unknown FileGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileGroupMutation) ResetEdge(name string) error {
	switch name {
	case filegroup.EdgeFiles:
		m.ResetFiles()
		return nil
	case filegroup.EdgeGame:
		m.ResetGame()
		return nil
	}
	return fmt.Errorf("unknown FileGroup edge %s", name)
}

// FileReactionMutation represents an operation that mutates the FileReaction nodes in the graph.
type FileReactionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	user_id       *string
	value         *int
	addvalue      *int
	clearedFields map[string]struct{}
	file          *string
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*FileReaction, error)
	predicates    []predicate.FileReaction
}

var _ ent.Mutation = (*FileReactionMutation)(nil)

// filereactionOption allows management of the mutation configuration using functional options.
type filereactionOption func(*FileReactionMutation)

// newFileReactionMutation creates new mutation for the FileReaction entity.
func newFileReactionMutation(c config, op Op, opts ...filereactionOption) *FileReactionMutation {
	m := &FileReactionMutation{
		config:        c,
		op:            op,
		typ:           TypeFileReaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileReactionID sets the ID field of the mutation.
func withFileReactionID(id string) filereactionOption {
	return func(m *FileReactionMutation) {
		var (
			err   error
			once  sync.Once
			value *FileReaction
		)
		m.oldValue = func(ctx context.Context) (*FileReaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileReaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileReaction sets the old FileReaction of the mutation.
func withFileReaction(node *FileReaction) filereactionOption {
	return func(m *FileReactionMutation) {
		m.oldValue = func(context.Context) (*FileReaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileReactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileReactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileReaction entities.
func (m *FileReactionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileReactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileReactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileReaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *FileReactionMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FileReactionMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FileReaction entity.
// If the FileReaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileReactionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FileReactionMutation) ResetUserID() {
	m.user_id = nil
}

// SetValue sets the "value" field.
func (m *FileReactionMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *FileReactionMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the FileReaction entity.
// If the FileReaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileReactionMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *FileReactionMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *FileReactionMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *FileReactionMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *FileReactionMutation) SetFileID(id string) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *FileReactionMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *FileReactionMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *FileReactionMutation) FileID() (id string, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *FileReactionMutation) FileIDs() (ids []string) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *FileReactionMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the FileReactionMutation builder.
func (m *FileReactionMutation) Where(ps ...predicate.FileReaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileReactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileReactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileReaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileReactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileReactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileReaction).
func (m *FileReactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileReactionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user_id != nil {
		fields = append(fields, filereaction.FieldUserID)
	}
	if m.value != nil {
		fields = append(fields, filereaction.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileReactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filereaction.FieldUserID:
		return m.UserID()
	case filereaction.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileReactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filereaction.FieldUserID:
		return m.OldUserID(ctx)
	case filereaction.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown FileReaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileReactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filereaction.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case filereaction.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown FileReaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileReactionMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, filereaction.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileReactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filereaction.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileReactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filereaction.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown FileReaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileReactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileReactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileReactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileReaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileReactionMutation) ResetField(name string) error {
	switch name {
	case filereaction.FieldUserID:
		m.ResetUserID()
		return nil
	case filereaction.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown FileReaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileReactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, filereaction.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileReactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filereaction.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileReactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileReactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileReactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, filereaction.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileReactionMutation) EdgeCleared(name string) bool {
	switch name {
	case filereaction.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileReactionMutation) ClearEdge(name string) error {
	switch name {
	case filereaction.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown FileReaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileReactionMutation) ResetEdge(name string) error {
	switch name {
	case filereaction.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown FileReaction edge %s", name)
}

// GameMutation represents an operation that mutates the Game nodes in the graph.
type GameMutation struct {
	config
	op              Op
	typ             string
	id              *string
	slug            *string
	platform        *game.Platform
	title           *string
	year            *int
	addyear         *int
	publisher       *string
	developer       *string
	clearedFields   map[string]struct{}
	files           map[string]struct{}
	removedfiles    map[string]struct{}
	clearedfiles    bool
	images          map[string]struct{}
	removedimages   map[string]struct{}
	clearedimages   bool
	comments        map[string]struct{}
	removedcomments map[string]struct{}
	clearedcomments bool
	groups          map[string]struct{}
	removedgroups   map[string]struct{}
	clearedgroups   bool
	likes           map[string]struct{}
	removedlikes    map[string]struct{}
	clearedlikes    bool
	done            bool
	oldValue        func(context.Context) (*Game, error)
	predicates      []predicate.Game
}

var _ ent.Mutation = (*GameMutation)(nil)

// gameOption allows management of the mutation configuration using functional options.
type gameOption func(*GameMutation)

// newGameMutation creates new mutation for the Game entity.
func newGameMutation(c config, op Op, opts ...gameOption) *GameMutation {
	m := &GameMutation{
		config:        c,
		op:            op,
		typ:           TypeGame,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameID sets the ID field of the mutation.
func withGameID(id string) gameOption {
	return func(m *GameMutation) {
		var (
			err   error
			once  sync.Once
			value *Game
		)
		m.oldValue = func(ctx context.Context) (*Game, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Game.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGame sets the old Game of the mutation.
func withGame(node *Game) gameOption {
	return func(m *GameMutation) {
		m.oldValue = func(context.Context) (*Game, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Game entities.
func (m *GameMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Game.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *GameMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *GameMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *GameMutation) ResetSlug() {
	m.slug = nil
}

// SetPlatform sets the "platform" field.
func (m *GameMutation) SetPlatform(ga game.Platform) {
	m.platform = &ga
}

// Platform returns the value of the "platform" field in the mutation.
func (m *GameMutation) Platform() (r game.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldPlatform(ctx context.Context) (v game.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *GameMutation) ResetPlatform() {
	m.platform = nil
}

// SetTitle sets the "title" field.
func (m *GameMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GameMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GameMutation) ResetTitle() {
	m.title = nil
}

// SetYear sets the "year" field.
func (m *GameMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *GameMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldYear(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *GameMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *GameMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *GameMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[game.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *GameMutation) YearCleared() bool {
	_, ok := m.clearedFields[game.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *GameMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, game.FieldYear)
}

// SetPublisher sets the "publisher" field.
func (m *GameMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *GameMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *GameMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[game.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *GameMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[game.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *GameMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, game.FieldPublisher)
}

// SetDeveloper sets the "developer" field.
func (m *GameMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *GameMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *GameMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[game.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *GameMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[game.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *GameMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, game.FieldDeveloper)
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *GameMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *GameMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *GameMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *GameMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *GameMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *GameMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *GameMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *GameMutation) AddImageIDs(ids ...string) {
	if m.images == nil {
		m.images = make(map[string]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *GameMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *GameMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *GameMutation) RemoveImageIDs(ids ...string) {
	if m.removedimages == nil {
		m.removedimages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *GameMutation) RemovedImagesIDs() (ids []string) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *GameMutation) ImagesIDs() (ids []string) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *GameMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *GameMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *GameMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *GameMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *GameMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *GameMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *GameMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *GameMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddGroupIDs adds the "groups" edge to the FileGroup entity by ids.
func (m *GameMutation) AddGroupIDs(ids ...string) {
	if m.groups == nil {
		m.groups = make(map[string]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the FileGroup entity.
func (m *GameMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the FileGroup entity was cleared.
func (m *GameMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the FileGroup entity by IDs.
func (m *GameMutation) RemoveGroupIDs(ids ...string) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the FileGroup entity.
func (m *GameMutation) RemovedGroupsIDs() (ids []string) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *GameMutation) GroupsIDs() (ids []string) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *GameMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddLikeIDs adds the "likes" edge to the GameLike entity by ids.
func (m *GameMutation) AddLikeIDs(ids ...string) {
	if m.likes == nil {
		m.likes = make(map[string]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the GameLike entity.
func (m *GameMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the GameLike entity was cleared.
func (m *GameMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the GameLike entity by IDs.
func (m *GameMutation) RemoveLikeIDs(ids ...string) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the GameLike entity.
func (m *GameMutation) RemovedLikesIDs() (ids []string) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *GameMutation) LikesIDs() (ids []string) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *GameMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// Where appends a list predicates to the GameMutation builder.
func (m *GameMutation) Where(ps ...predicate.Game) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Game, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Game).
func (m *GameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.slug != nil {
		fields = append(fields, game.FieldSlug)
	}
	if m.platform != nil {
		fields = append(fields, game.FieldPlatform)
	}
	if m.title != nil {
		fields = append(fields, game.FieldTitle)
	}
	if m.year != nil {
		fields = append(fields, game.FieldYear)
	}
	if m.publisher != nil {
		fields = append(fields, game.FieldPublisher)
	}
	if m.developer != nil {
		fields = append(fields, game.FieldDeveloper)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case game.FieldSlug:
		return m.Slug()
	case game.FieldPlatform:
		return m.Platform()
	case game.FieldTitle:
		return m.Title()
	case game.FieldYear:
		return m.Year()
	case game.FieldPublisher:
		return m.Publisher()
	case game.FieldDeveloper:
		return m.Developer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case game.FieldSlug:
		return m.OldSlug(ctx)
	case game.FieldPlatform:
		return m.OldPlatform(ctx)
	case game.FieldTitle:
		return m.OldTitle(ctx)
	case game.FieldYear:
		return m.OldYear(ctx)
	case game.FieldPublisher:
		return m.OldPublisher(ctx)
	case game.FieldDeveloper:
		return m.OldDeveloper(ctx)
	}
	return nil, fmt.Errorf("unknown Game field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case game.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case game.FieldPlatform:
		v, ok := value.(game.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case game.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case game.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case game.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case game.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, game.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case game.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) AddField(name string, value ent.Value) error {
	switch name {
	case game.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Game numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(game.FieldYear) {
		fields = append(fields, game.FieldYear)
	}
	if m.FieldCleared(game.FieldPublisher) {
		fields = append(fields, game.FieldPublisher)
	}
	if m.FieldCleared(game.FieldDeveloper) {
		fields = append(fields, game.FieldDeveloper)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameMutation) ClearField(name string) error {
	switch name {
	case game.FieldYear:
		m.ClearYear()
		return nil
	case game.FieldPublisher:
		m.ClearPublisher()
		return nil
	case game.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	}
	return fmt.Errorf("unknown Game nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameMutation) ResetField(name string) error {
	switch name {
	case game.FieldSlug:
		m.ResetSlug()
		return nil
	case game.FieldPlatform:
		m.ResetPlatform()
		return nil
	case game.FieldTitle:
		m.ResetTitle()
		return nil
	case game.FieldYear:
		m.ResetYear()
		return nil
	case game.FieldPublisher:
		m.ResetPublisher()
		return nil
	case game.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.files != nil {
		edges = append(edges, game.EdgeFiles)
	}
	if m.images != nil {
		edges = append(edges, game.EdgeImages)
	}
	if m.comments != nil {
		edges = append(edges, game.EdgeComments)
	}
	if m.groups != nil {
		edges = append(edges, game.EdgeGroups)
	}
	if m.likes != nil {
		edges = append(edges, game.EdgeLikes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedfiles != nil {
		edges = append(edges, game.EdgeFiles)
	}
	if m.removedimages != nil {
		edges = append(edges, game.EdgeImages)
	}
	if m.removedcomments != nil {
		edges = append(edges, game.EdgeComments)
	}
	if m.removedgroups != nil {
		edges = append(edges, game.EdgeGroups)
	}
	if m.removedlikes != nil {
		edges = append(edges, game.EdgeLikes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedfiles {
		edges = append(edges, game.EdgeFiles)
	}
	if m.clearedimages {
		edges = append(edges, game.EdgeImages)
	}
	if m.clearedcomments {
		edges = append(edges, game.EdgeComments)
	}
	if m.clearedgroups {
		edges = append(edges, game.EdgeGroups)
	}
	if m.clearedlikes {
		edges = append(edges, game.EdgeLikes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameMutation) EdgeCleared(name string) bool {
	switch name {
	case game.EdgeFiles:
		return m.clearedfiles
	case game.EdgeImages:
		return m.clearedimages
	case game.EdgeComments:
		return m.clearedcomments
	case game.EdgeGroups:
		return m.clearedgroups
	case game.EdgeLikes:
		return m.clearedlikes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Game unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameMutation) ResetEdge(name string) error {
	switch name {
	case game.EdgeFiles:
		m.ResetFiles()
		return nil
	case game.EdgeImages:
		m.ResetImages()
		return nil
	case game.EdgeComments:
		m.ResetComments()
		return nil
	case game.EdgeGroups:
		m.ResetGroups()
		return nil
	case game.EdgeLikes:
		m.ResetLikes()
		return nil
	}
	return fmt.Errorf("unknown Game edge %s", name)
}

// GameLikeMutation represents an operation that mutates the GameLike nodes in the graph.
type GameLikeMutation struct {
	config
	op            Op
	typ           string
	id            *string
	user_id       *string
	clearedFields map[string]struct{}
	game          *string
	clearedgame   bool
	done          bool
	oldValue      func(context.Context) (*GameLike, error)
	predicates    []predicate.GameLike
}

var _ ent.Mutation = (*GameLikeMutation)(nil)

// gamelikeOption allows management of the mutation configuration using functional options.
type gamelikeOption func(*GameLikeMutation)

// newGameLikeMutation creates new mutation for the GameLike entity.
func newGameLikeMutation(c config, op Op, opts ...gamelikeOption) *GameLikeMutation {
	m := &GameLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeGameLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameLikeID sets the ID field of the mutation.
func withGameLikeID(id string) gamelikeOption {
	return func(m *GameLikeMutation) {
		var (
			err   error
			once  sync.Once
			value *GameLike
		)
		m.oldValue = func(ctx context.Context) (*GameLike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameLike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameLike sets the old GameLike of the mutation.
func withGameLike(node *GameLike) gamelikeOption {
	return func(m *GameLikeMutation) {
		m.oldValue = func(context.Context) (*GameLike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameLike entities.
func (m *GameLikeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameLikeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameLikeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameLike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *GameLikeMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GameLikeMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GameLike entity.
// If the GameLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameLikeMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GameLikeMutation) ResetUserID() {
	m.user_id = nil
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *GameLikeMutation) SetGameID(id string) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *GameLikeMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *GameLikeMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *GameLikeMutation) GameID() (id string, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *GameLikeMutation) GameIDs() (ids []string) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *GameLikeMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// Where appends a list predicates to the GameLikeMutation builder.
func (m *GameLikeMutation) Where(ps ...predicate.GameLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameLike).
func (m *GameLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameLikeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.user_id != nil {
		fields = append(fields, gamelike.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gamelike.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gamelike.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown GameLike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gamelike.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown GameLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameLikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameLikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameLikeMutation) ResetField(name string) error {
	switch name {
	case gamelike.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown GameLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.game != nil {
		edges = append(edges, gamelike.EdgeGame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gamelike.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgame {
		edges = append(edges, gamelike.EdgeGame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case gamelike.EdgeGame:
		return m.clearedgame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameLikeMutation) ClearEdge(name string) error {
	switch name {
	case gamelike.EdgeGame:
		m.ClearGame()
		return nil
	}
	return fmt.Errorf("unknown GameLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameLikeMutation) ResetEdge(name string) error {
	switch name {
	case gamelike.EdgeGame:
		m.ResetGame()
		return nil
	}
	return fmt.Errorf("unknown GameLike edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *string
	kind          *image.Kind
	position      *int
	addposition   *int
	s3_key        *string
	width         *int
	addwidth      *int
	height        *int
	addheight     *int
	clearedFields map[string]struct{}
	game          *string
	clearedgame   bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id string) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKind sets the "kind" field.
func (m *ImageMutation) SetKind(i image.Kind) {
	m.kind = &i
}

// Kind returns the value of the "kind" field in the mutation.
func (m *ImageMutation) Kind() (r image.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldKind(ctx context.Context) (v image.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *ImageMutation) ResetKind() {
	m.kind = nil
}

// SetPosition sets the "position" field.
func (m *ImageMutation) SetPosition(i int) {
	m.position = &i
	m.addposition = nil
}

// Position returns the value of the "position" field in the mutation.
func (m *ImageMutation) Position() (r int, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldPosition(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// AddPosition adds i to the "position" field.
func (m *ImageMutation) AddPosition(i int) {
	if m.addposition != nil {
		*m.addposition += i
	} else {
		m.addposition = &i
	}
}

// AddedPosition returns the value that was added to the "position" field in this mutation.
func (m *ImageMutation) AddedPosition() (r int, exists bool) {
	v := m.addposition
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosition resets all changes to the "position" field.
func (m *ImageMutation) ResetPosition() {
	m.position = nil
	m.addposition = nil
}

// SetS3Key sets the "s3_key" field.
func (m *ImageMutation) SetS3Key(s string) {
	m.s3_key = &s
}

// S3Key returns the value of the "s3_key" field in the mutation.
func (m *ImageMutation) S3Key() (r string, exists bool) {
	v := m.s3_key
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Key returns the old "s3_key" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldS3Key(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Key is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Key requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Key: %w", err)
	}
	return oldValue.S3Key, nil
}

// ResetS3Key resets all changes to the "s3_key" field.
func (m *ImageMutation) ResetS3Key() {
	m.s3_key = nil
}

// SetWidth sets the "width" field.
func (m *ImageMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ImageMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ImageMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ImageMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *ImageMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *ImageMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ImageMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *ImageMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ImageMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *ImageMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *ImageMutation) SetGameID(id string) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *ImageMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *ImageMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *ImageMutation) GameID() (id string, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) GameIDs() (ids []string) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *ImageMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.kind != nil {
		fields = append(fields, image.FieldKind)
	}
	if m.position != nil {
		fields = append(fields, image.FieldPosition)
	}
	if m.s3_key != nil {
		fields = append(fields, image.FieldS3Key)
	}
	if m.width != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, image.FieldHeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldKind:
		return m.Kind()
	case image.FieldPosition:
		return m.Position()
	case image.FieldS3Key:
		return m.S3Key()
	case image.FieldWidth:
		return m.Width()
	case image.FieldHeight:
		return m.Height()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldKind:
		return m.OldKind(ctx)
	case image.FieldPosition:
		return m.OldPosition(ctx)
	case image.FieldS3Key:
		return m.OldS3Key(ctx)
	case image.FieldWidth:
		return m.OldWidth(ctx)
	case image.FieldHeight:
		return m.OldHeight(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldKind:
		v, ok := value.(image.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case image.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case image.FieldS3Key:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Key(v)
		return nil
	case image.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case image.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	var fields []string
	if m.addposition != nil {
		fields = append(fields, image.FieldPosition)
	}
	if m.addwidth != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, image.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case image.FieldPosition:
		return m.AddedPosition()
	case image.FieldWidth:
		return m.AddedWidth()
	case image.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case image.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosition(v)
		return nil
	case image.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case image.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldKind:
		m.ResetKind()
		return nil
	case image.FieldPosition:
		m.ResetPosition()
		return nil
	case image.FieldS3Key:
		m.ResetS3Key()
		return nil
	case image.FieldWidth:
		m.ResetWidth()
		return nil
	case image.FieldHeight:
		m.ResetHeight()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.game != nil {
		edges = append(edges, image.EdgeGame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgame {
		edges = append(edges, image.EdgeGame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeGame:
		return m.clearedgame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeGame:
		m.ClearGame()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeGame:
		m.ResetGame()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op            Op
	typ           string
	id            *string
	subject_type  *string
	subject_id    *string
	reporter_id   *string
	reason        *string
	note          *string
	status        *report.Status
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Report, error)
	predicates    []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id string) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Report entities.
func (m *ReportMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubjectType sets the "subject_type" field.
func (m *ReportMutation) SetSubjectType(s string) {
	m.subject_type = &s
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *ReportMutation) SubjectType() (r string, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldSubjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *ReportMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *ReportMutation) SetSubjectID(s string) {
	m.subject_id = &s
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *ReportMutation) SubjectID() (r string, exists bool) {
	v := m.subject_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldSubjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *ReportMutation) ResetSubjectID() {
	m.subject_id = nil
}

// SetReporterID sets the "reporter_id" field.
func (m *ReportMutation) SetReporterID(s string) {
	m.reporter_id = &s
}

// ReporterID returns the value of the "reporter_id" field in the mutation.
func (m *ReportMutation) ReporterID() (r string, exists bool) {
	v := m.reporter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReporterID returns the old "reporter_id" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReporterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporterID: %w", err)
	}
	return oldValue.ReporterID, nil
}

// ClearReporterID clears the value of the "reporter_id" field.
func (m *ReportMutation) ClearReporterID() {
	m.reporter_id = nil
	m.clearedFields[report.FieldReporterID] = struct{}{}
}

// ReporterIDCleared returns if the "reporter_id" field was cleared in this mutation.
func (m *ReportMutation) ReporterIDCleared() bool {
	_, ok := m.clearedFields[report.FieldReporterID]
	return ok
}

// ResetReporterID resets all changes to the "reporter_id" field.
func (m *ReportMutation) ResetReporterID() {
	m.reporter_id = nil
	delete(m.clearedFields, report.FieldReporterID)
}

// SetReason sets the "reason" field.
func (m *ReportMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ReportMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *ReportMutation) ResetReason() {
	m.reason = nil
}

// SetNote sets the "note" field.
func (m *ReportMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *ReportMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *ReportMutation) ClearNote() {
	m.note = nil
	m.clearedFields[report.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *ReportMutation) NoteCleared() bool {
	_, ok := m.clearedFields[report.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *ReportMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, report.FieldNote)
}

// SetStatus sets the "status" field.
func (m *ReportMutation) SetStatus(r report.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReportMutation) Status() (r report.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldStatus(ctx context.Context) (v report.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReportMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Report, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.subject_type != nil {
		fields = append(fields, report.FieldSubjectType)
	}
	if m.subject_id != nil {
		fields = append(fields, report.FieldSubjectID)
	}
	if m.reporter_id != nil {
		fields = append(fields, report.FieldReporterID)
	}
	if m.reason != nil {
		fields = append(fields, report.FieldReason)
	}
	if m.note != nil {
		fields = append(fields, report.FieldNote)
	}
	if m.status != nil {
		fields = append(fields, report.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldSubjectType:
		return m.SubjectType()
	case report.FieldSubjectID:
		return m.SubjectID()
	case report.FieldReporterID:
		return m.ReporterID()
	case report.FieldReason:
		return m.Reason()
	case report.FieldNote:
		return m.Note()
	case report.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case report.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case report.FieldReporterID:
		return m.OldReporterID(ctx)
	case report.FieldReason:
		return m.OldReason(ctx)
	case report.FieldNote:
		return m.OldNote(ctx)
	case report.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldSubjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case report.FieldSubjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case report.FieldReporterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporterID(v)
		return nil
	case report.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case report.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case report.FieldStatus:
		v, ok := value.(report.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(report.FieldReporterID) {
		fields = append(fields, report.FieldReporterID)
	}
	if m.FieldCleared(report.FieldNote) {
		fields = append(fields, report.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	switch name {
	case report.FieldReporterID:
		m.ClearReporterID()
		return nil
	case report.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case report.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case report.FieldReporterID:
		m.ResetReporterID()
		return nil
	case report.FieldReason:
		m.ResetReason()
		return nil
	case report.FieldNote:
		m.ResetNote()
		return nil
	case report.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Report edge %s", name)
}

// SiteSettingMutation represents an operation that mutates the SiteSetting nodes in the graph.
type SiteSettingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	key           *string
	value         *json.RawMessage
	appendvalue   json.RawMessage
	public        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SiteSetting, error)
	predicates    []predicate.SiteSetting
}

var _ ent.Mutation = (*SiteSettingMutation)(nil)

// sitesettingOption allows management of the mutation configuration using functional options.
type sitesettingOption func(*SiteSettingMutation)

// newSiteSettingMutation creates new mutation for the SiteSetting entity.
func newSiteSettingMutation(c config, op Op, opts ...sitesettingOption) *SiteSettingMutation {
	m := &SiteSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSiteSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSiteSettingID sets the ID field of the mutation.
func withSiteSettingID(id string) sitesettingOption {
	return func(m *SiteSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *SiteSetting
		)
		m.oldValue = func(ctx context.Context) (*SiteSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SiteSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSiteSetting sets the old SiteSetting of the mutation.
func withSiteSetting(node *SiteSetting) sitesettingOption {
	return func(m *SiteSettingMutation) {
		m.oldValue = func(context.Context) (*SiteSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SiteSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SiteSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SiteSetting entities.
func (m *SiteSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SiteSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SiteSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SiteSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SiteSettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SiteSettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SiteSetting entity.
// If the SiteSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteSettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SiteSettingMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SiteSettingMutation) SetValue(jm json.RawMessage) {
	m.value = &jm
	m.appendvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *SiteSettingMutation) Value() (r json.RawMessage, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SiteSetting entity.
// If the SiteSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteSettingMutation) OldValue(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AppendValue adds jm to the "value" field.
func (m *SiteSettingMutation) AppendValue(jm json.RawMessage) {
	m.appendvalue = append(m.appendvalue, jm...)
}

// AppendedValue returns the list of values that were appended to the "value" field in this mutation.
func (m *SiteSettingMutation) AppendedValue() (json.RawMessage, bool) {
	if len(m.appendvalue) == 0 {
		return nil, false
	}
	return m.appendvalue, true
}

// ClearValue clears the value of the "value" field.
func (m *SiteSettingMutation) ClearValue() {
	m.value = nil
	m.appendvalue = nil
	m.clearedFields[sitesetting.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *SiteSettingMutation) ValueCleared() bool {
	_, ok := m.clearedFields[sitesetting.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *SiteSettingMutation) ResetValue() {
	m.value = nil
	m.appendvalue = nil
	delete(m.clearedFields, sitesetting.FieldValue)
}

// SetPublic sets the "public" field.
func (m *SiteSettingMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *SiteSettingMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the SiteSetting entity.
// If the SiteSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteSettingMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *SiteSettingMutation) ResetPublic() {
	m.public = nil
}

// Where appends a list predicates to the SiteSettingMutation builder.
func (m *SiteSettingMutation) Where(ps ...predicate.SiteSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SiteSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SiteSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SiteSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SiteSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SiteSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SiteSetting).
func (m *SiteSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SiteSettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, sitesetting.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, sitesetting.FieldValue)
	}
	if m.public != nil {
		fields = append(fields, sitesetting.FieldPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SiteSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sitesetting.FieldKey:
		return m.Key()
	case sitesetting.FieldValue:
		return m.Value()
	case sitesetting.FieldPublic:
		return m.Public()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SiteSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sitesetting.FieldKey:
		return m.OldKey(ctx)
	case sitesetting.FieldValue:
		return m.OldValue(ctx)
	case sitesetting.FieldPublic:
		return m.OldPublic(ctx)
	}
	return nil, fmt.Errorf("unknown SiteSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sitesetting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case sitesetting.FieldValue:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case sitesetting.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	}
	return fmt.Errorf("unknown SiteSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SiteSettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SiteSettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SiteSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SiteSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sitesetting.FieldValue) {
		fields = append(fields, sitesetting.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SiteSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SiteSettingMutation) ClearField(name string) error {
	switch name {
	case sitesetting.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown SiteSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SiteSettingMutation) ResetField(name string) error {
	switch name {
	case sitesetting.FieldKey:
		m.ResetKey()
		return nil
	case sitesetting.FieldValue:
		m.ResetValue()
		return nil
	case sitesetting.FieldPublic:
		m.ResetPublic()
		return nil
	}
	return fmt.Errorf("unknown SiteSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SiteSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SiteSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SiteSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SiteSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SiteSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SiteSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SiteSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SiteSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SiteSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SiteSetting edge %s", name)
}

// UserShadowMutation represents an operation that mutates the UserShadow nodes in the graph.
type UserShadowMutation struct {
	config
	op            Op
	typ           string
	id            *string
	keycloak_sub  *string
	handle        *string
	display_name  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserShadow, error)
	predicates    []predicate.UserShadow
}

var _ ent.Mutation = (*UserShadowMutation)(nil)

// usershadowOption allows management of the mutation configuration using functional options.
type usershadowOption func(*UserShadowMutation)

// newUserShadowMutation creates new mutation for the UserShadow entity.
func newUserShadowMutation(c config, op Op, opts ...usershadowOption) *UserShadowMutation {
	m := &UserShadowMutation{
		config:        c,
		op:            op,
		typ:           TypeUserShadow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserShadowID sets the ID field of the mutation.
func withUserShadowID(id string) usershadowOption {
	return func(m *UserShadowMutation) {
		var (
			err   error
			once  sync.Once
			value *UserShadow
		)
		m.oldValue = func(ctx context.Context) (*UserShadow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserShadow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserShadow sets the old UserShadow of the mutation.
func withUserShadow(node *UserShadow) usershadowOption {
	return func(m *UserShadowMutation) {
		m.oldValue = func(context.Context) (*UserShadow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserShadowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserShadowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserShadow entities.
func (m *UserShadowMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserShadowMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserShadowMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserShadow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKeycloakSub sets the "keycloak_sub" field.
func (m *UserShadowMutation) SetKeycloakSub(s string) {
	m.keycloak_sub = &s
}

// KeycloakSub returns the value of the "keycloak_sub" field in the mutation.
func (m *UserShadowMutation) KeycloakSub() (r string, exists bool) {
	v := m.keycloak_sub
	if v == nil {
		return
	}
	return *v, true
}

// OldKeycloakSub returns the old "keycloak_sub" field's value of the UserShadow entity.
// If the UserShadow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserShadowMutation) OldKeycloakSub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeycloakSub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeycloakSub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeycloakSub: %w", err)
	}
	return oldValue.KeycloakSub, nil
}

// ResetKeycloakSub resets all changes to the "keycloak_sub" field.
func (m *UserShadowMutation) ResetKeycloakSub() {
	m.keycloak_sub = nil
}

// SetHandle sets the "handle" field.
func (m *UserShadowMutation) SetHandle(s string) {
	m.handle = &s
}

// Handle returns the value of the "handle" field in the mutation.
func (m *UserShadowMutation) Handle() (r string, exists bool) {
	v := m.handle
	if v == nil {
		return
	}
	return *v, true
}

// OldHandle returns the old "handle" field's value of the UserShadow entity.
// If the UserShadow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserShadowMutation) OldHandle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandle: %w", err)
	}
	return oldValue.Handle, nil
}

// ClearHandle clears the value of the "handle" field.
func (m *UserShadowMutation) ClearHandle() {
	m.handle = nil
	m.clearedFields[usershadow.FieldHandle] = struct{}{}
}

// HandleCleared returns if the "handle" field was cleared in this mutation.
func (m *UserShadowMutation) HandleCleared() bool {
	_, ok := m.clearedFields[usershadow.FieldHandle]
	return ok
}

// ResetHandle resets all changes to the "handle" field.
func (m *UserShadowMutation) ResetHandle() {
	m.handle = nil
	delete(m.clearedFields, usershadow.FieldHandle)
}

// SetDisplayName sets the "display_name" field.
func (m *UserShadowMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserShadowMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the UserShadow entity.
// If the UserShadow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserShadowMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UserShadowMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[usershadow.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UserShadowMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[usershadow.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserShadowMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, usershadow.FieldDisplayName)
}

// Where appends a list predicates to the UserShadowMutation builder.
func (m *UserShadowMutation) Where(ps ...predicate.UserShadow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserShadowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserShadowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserShadow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserShadowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserShadowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserShadow).
func (m *UserShadowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserShadowMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.keycloak_sub != nil {
		fields = append(fields, usershadow.FieldKeycloakSub)
	}
	if m.handle != nil {
		fields = append(fields, usershadow.FieldHandle)
	}
	if m.display_name != nil {
		fields = append(fields, usershadow.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserShadowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usershadow.FieldKeycloakSub:
		return m.KeycloakSub()
	case usershadow.FieldHandle:
		return m.Handle()
	case usershadow.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserShadowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usershadow.FieldKeycloakSub:
		return m.OldKeycloakSub(ctx)
	case usershadow.FieldHandle:
		return m.OldHandle(ctx)
	case usershadow.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown UserShadow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserShadowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usershadow.FieldKeycloakSub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeycloakSub(v)
		return nil
	case usershadow.FieldHandle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandle(v)
		return nil
	case usershadow.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown UserShadow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserShadowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserShadowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserShadowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserShadow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserShadowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usershadow.FieldHandle) {
		fields = append(fields, usershadow.FieldHandle)
	}
	if m.FieldCleared(usershadow.FieldDisplayName) {
		fields = append(fields, usershadow.FieldDisplayName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserShadowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserShadowMutation) ClearField(name string) error {
	switch name {
	case usershadow.FieldHandle:
		m.ClearHandle()
		return nil
	case usershadow.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	}
	return fmt.Errorf("unknown UserShadow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserShadowMutation) ResetField(name string) error {
	switch name {
	case usershadow.FieldKeycloakSub:
		m.ResetKeycloakSub()
		return nil
	case usershadow.FieldHandle:
		m.ResetHandle()
		return nil
	case usershadow.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown UserShadow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserShadowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserShadowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserShadowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserShadowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserShadowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserShadowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserShadowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserShadow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserShadowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserShadow edge %s", name)
}
