package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/deicod/archivedgames/ent"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/filereaction"
	"github.com/deicod/archivedgames/ent/game"
	"github.com/deicod/archivedgames/ent/gamelike"
	"github.com/deicod/archivedgames/ent/image"
	"github.com/deicod/archivedgames/ent/report"
	"github.com/deicod/archivedgames/ent/sitesetting"
	"github.com/deicod/archivedgames/graph/model"
	"github.com/deicod/archivedgames/internal/auth"
	"github.com/deicod/archivedgames/internal/gqltypes"
	"github.com/deicod/archivedgames/internal/imageproc"
	reqctx "github.com/deicod/archivedgames/internal/request"
	"github.com/deicod/archivedgames/internal/s3client"
	"github.com/deicod/archivedgames/internal/sanitize"
)

// ReactionSummary is the resolver for the reactionSummary field.
func (r *fileResolver) ReactionSummary(ctx context.Context, obj *ent.File) (*model.ReactionSummary, error) {
	uid, _ := auth.UserID(ctx)
	up, _ := r.Client.FileReaction.Query().Where(filereaction.HasFileWith(file.IDEQ(obj.ID)), filereaction.ValueEQ(1)).Count(ctx)
	down, _ := r.Client.FileReaction.Query().Where(filereaction.HasFileWith(file.IDEQ(obj.ID)), filereaction.ValueEQ(-1)).Count(ctx)
	viewer := 0
	if uid != "" {
		if fr, err := r.Client.FileReaction.Query().Where(filereaction.HasFileWith(file.IDEQ(obj.ID)), filereaction.UserID(uid)).Only(ctx); err == nil {
			viewer = fr.Value
		}
	}
	return &model.ReactionSummary{Up: up, Down: down, Viewer: viewer}, nil
}

// ViewerDidLike is the resolver for the viewerDidLike field.
func (r *gameResolver) ViewerDidLike(ctx context.Context, obj *ent.Game) (bool, error) {
	uid, ok := auth.UserID(ctx)
	if !ok {
		return false, nil
	}
	cnt, err := r.Client.GameLike.Query().Where(gamelike.HasGameWith(game.IDEQ(obj.ID)), gamelike.UserID(uid)).Count(ctx)
	return cnt > 0, err
}

// CreateImageUploads is the resolver for the createImageUploads field.
func (r *mutationResolver) CreateImageUploads(ctx context.Context, gameID string, kind image.Kind, count int) ([]*model.PresignedPut, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return nil, err
	}
	g, err := r.Client.Game.Query().Where(game.IDEQ(gameID)).Only(ctx)
	if err != nil {
		return nil, err
	}
	if count <= 0 || count > 10 {
		count = 1
	}
	s3c, err := s3client.New(ctx)
	if err != nil {
		return nil, err
	}
	now := time.Now().Unix()
	out := make([]*model.PresignedPut, 0, count)
	for i := 0; i < count; i++ {
		key := fmt.Sprintf("images/%s/%d/%d.jpg", g.ID, now, i)
		url, err := s3c.PresignPut(ctx, key, "image/jpeg", 10*time.Minute)
		if err != nil {
			return nil, err
		}
		out = append(out, &model.PresignedPut{Key: key, URL: url})
	}
	return out, nil
}

// FinalizeImageUploads is the resolver for the finalizeImageUploads field.
func (r *mutationResolver) FinalizeImageUploads(ctx context.Context, gameID string, kind image.Kind, items []*model.UploadedImageInput) ([]*ent.Image, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return nil, err
	}
	g, err := r.Client.Game.Query().Where(game.IDEQ(gameID)).Only(ctx)
	if err != nil {
		return nil, err
	}
	created := make([]*ent.Image, 0, len(items))
	for idx, it := range items {
		img, err := r.Client.Image.Create().
			SetGame(g).
			SetKind(kind).
			SetPosition(idx).
			SetS3Key(it.Key).
			SetWidth(it.Width).
			SetHeight(it.Height).
			Save(ctx)
		if err != nil {
			return nil, err
		}
		created = append(created, img)
		// Best-effort derive thumbnails for newly uploaded image
		if s3c, err := s3client.New(ctx); err == nil {
			_ = imageproc.Derive(ctx, s3c, it.Key, []int{128, 512})
		}
	}
	return created, nil
}

// SetSiteSetting is the resolver for the setSiteSetting field.
func (r *mutationResolver) SetSiteSetting(ctx context.Context, key string, value gqltypes.RawMessage, public *bool) (*ent.SiteSetting, error) {
	// Admin guard
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	// Try update
	upd := r.Client.SiteSetting.Update().Where(sitesetting.KeyEQ(key)).SetValue(json.RawMessage(value))
	if public != nil {
		upd = upd.SetPublic(*public)
	}
	if err := upd.Exec(ctx); err == nil {
		return r.Client.SiteSetting.Query().Where(sitesetting.KeyEQ(key)).Only(ctx)
	}
	// Create new
	create := r.Client.SiteSetting.Create().SetKey(key).SetValue(json.RawMessage(value))
	if public != nil {
		create = create.SetPublic(*public)
	}
	return create.Save(ctx)
}

// ReportContent is the resolver for the reportContent field.
func (r *mutationResolver) ReportContent(ctx context.Context, subjectType string, subjectID string, reason string, note *string) (*ent.Report, error) {
	rid, _ := auth.UserID(ctx)
	create := r.Client.Report.Create().SetSubjectType(subjectType).SetSubjectID(subjectID).SetReason(reason)
	if rid != "" {
		create = create.SetReporterID(rid)
	}
	if note != nil {
		create = create.SetNote(*note)
	}
	return create.Save(ctx)
}

// QuarantineFile is the resolver for the quarantineFile field.
func (r *mutationResolver) QuarantineFile(ctx context.Context, fileID string, reason string) (*ent.File, error) {
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	f, err := r.Client.File.Query().Where(file.IDEQ(fileID)).Only(ctx)
	if err != nil {
		return nil, err
	}
	if err := r.Client.File.UpdateOne(f).SetQuarantine(true).Exec(ctx); err != nil {
		return nil, err
	}
	// audit as report actioned
	_, _ = r.Client.Report.Create().SetSubjectType("file").SetSubjectID(fileID).SetReason("quarantine").SetNote(reason).SetStatus("ACTIONED").Save(ctx)
	return r.Client.File.Get(ctx, f.ID)
}

// SetCoverImage is the resolver for the setCoverImage field.
func (r *mutationResolver) SetCoverImage(ctx context.Context, imageID string) (*ent.Image, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return nil, err
	}
	img, err := r.Client.Image.Get(ctx, imageID)
	if err != nil {
		return nil, err
	}
	gID, err := r.Client.Image.Query().Where(image.IDEQ(imageID)).QueryGame().OnlyID(ctx)
	if err != nil {
		return nil, err
	}
	if err := r.Client.Image.Update().Where(image.HasGameWith(game.IDEQ(gID)), image.KindEQ(image.KindCOVER)).SetKind(image.KindGALLERY).Exec(ctx); err != nil {
		return nil, err
	}
	if err := r.Client.Image.UpdateOne(img).SetKind(image.KindCOVER).SetPosition(0).Exec(ctx); err != nil {
		return nil, err
	}
	return r.Client.Image.Get(ctx, imageID)
}

// DeleteImage is the resolver for the deleteImage field.
func (r *mutationResolver) DeleteImage(ctx context.Context, imageID string) (bool, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return false, err
	}
	if err := r.Client.Image.DeleteOneID(imageID).Exec(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// SetReportStatus is the resolver for the setReportStatus field.
func (r *mutationResolver) SetReportStatus(ctx context.Context, reportID string, status report.Status, note *string) (*ent.Report, error) {
	// Admin guard
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	// Fetch current and update with optional admin note
	rep, err := r.Client.Report.Get(ctx, reportID)
	if err != nil {
		return nil, err
	}
	upd := r.Client.Report.UpdateOneID(reportID).SetStatus(status)
	if note != nil && *note != "" {
		merged := rep.Note
		if merged != "" {
			merged += " | "
		}
		merged += "admin: " + *note
		upd = upd.SetNote(merged)
	}
	if err := upd.Exec(ctx); err != nil {
		return nil, err
	}
	return r.Client.Report.Get(ctx, reportID)
}

// SetReportStatusBulk is the resolver for the setReportStatusBulk field.
func (r *mutationResolver) SetReportStatusBulk(ctx context.Context, reportIds []string, status report.Status, note *string) ([]*ent.Report, error) {
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	out := make([]*ent.Report, 0, len(reportIds))
	for _, id := range reportIds {
		rep, err := r.SetReportStatus(ctx, id, status, note)
		if err != nil {
			return nil, err
		}
		out = append(out, rep)
	}
	return out, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, subjectType string, subjectID string, content string, language *string) (*ent.Comment, error) {
	uid, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, err
	}
	ip := reqctx.FromContextIP(ctx)
	if r.Rate != nil {
		if err := r.Rate.AllowComment(uid, ip); err != nil {
			return nil, err
		}
	}
	sanitized := sanitize.HTML(content)
	// limit number of links
	maxLinks := 3
	if it, err := r.Client.SiteSetting.Query().Where(sitesetting.KeyEQ("comments.maxLinks")).Only(ctx); err == nil {
		var v int
		if len(it.Value) > 0 {
			_ = json.Unmarshal(it.Value, &v)
			if v > 0 {
				maxLinks = v
			}
		}
	}
	if strings.Count(sanitized, "<a ") > maxLinks {
		return nil, errors.New("too many links")
	}
	c := r.Client.Comment.Create().
		SetSubjectType(subjectType).
		SetSubjectID(subjectID).
		SetUserID(uid).
		SetContent(sanitized)
	if language != nil && *language != "" {
		c = c.SetLanguage(*language)
	}
	switch strings.ToLower(subjectType) {
	case "game":
		if _, err := r.Client.Game.Get(ctx, subjectID); err == nil {
			c = c.SetGameID(subjectID)
		}
	case "file":
		if _, err := r.Client.File.Get(ctx, subjectID); err == nil {
			c = c.SetFileID(subjectID)
		}
	}
	return c.Save(ctx)
}

// EditComment is the resolver for the editComment field.
func (r *mutationResolver) EditComment(ctx context.Context, id string, content string) (*ent.Comment, error) {
	uid, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, err
	}
	ip := reqctx.FromContextIP(ctx)
	if r.Rate != nil {
		if err := r.Rate.AllowComment(uid, ip); err != nil {
			return nil, err
		}
	}
	cm, err := r.Client.Comment.Get(ctx, id)
	if err != nil {
		return nil, err
	}
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin && cm.UserID != uid {
		return nil, errors.New("forbidden")
	}
	sanitized := sanitize.HTML(content)
	maxLinks := 3
	if it, err := r.Client.SiteSetting.Query().Where(sitesetting.KeyEQ("comments.maxLinks")).Only(ctx); err == nil {
		var v int
		if len(it.Value) > 0 {
			_ = json.Unmarshal(it.Value, &v)
			if v > 0 {
				maxLinks = v
			}
		}
	}
	if strings.Count(sanitized, "<a ") > maxLinks {
		return nil, errors.New("too many links")
	}
	now := time.Now()
	if err := r.Client.Comment.UpdateOneID(id).SetContent(sanitized).SetEditedAt(now).Exec(ctx); err != nil {
		return nil, err
	}
	return r.Client.Comment.Get(ctx, id)
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (bool, error) {
	uid, err := auth.RequireUser(ctx)
	if err != nil {
		return false, err
	}
	ip := reqctx.FromContextIP(ctx)
	if r.Rate != nil {
		if err := r.Rate.AllowComment(uid, ip); err != nil {
			return false, err
		}
	}
	cm, err := r.Client.Comment.Get(ctx, id)
	if err != nil {
		return false, err
	}
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin && cm.UserID != uid {
		return false, errors.New("forbidden")
	}
	now := time.Now()
	if err := r.Client.Comment.UpdateOneID(id).SetDeletedAt(now).SetContent("").Exec(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// RateGame is the resolver for the rateGame field.
func (r *mutationResolver) RateGame(ctx context.Context, gameID string, like bool) (*ent.Game, error) {
	uid, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, err
	}
	exists, _ := r.Client.GameLike.Query().Where(gamelike.HasGameWith(game.IDEQ(gameID)), gamelike.UserID(uid)).Exist(ctx)
	if like {
		if !exists {
			if _, err := r.Client.GameLike.Create().SetGameID(gameID).SetUserID(uid).Save(ctx); err != nil {
				return nil, err
			}
		}
	} else {
		if exists {
			if _, err := r.Client.GameLike.Delete().Where(gamelike.HasGameWith(game.IDEQ(gameID)), gamelike.UserID(uid)).Exec(ctx); err != nil {
				return nil, err
			}
		}
	}
	return r.Client.Game.Get(ctx, gameID)
}

// ReactToFile is the resolver for the reactToFile field.
func (r *mutationResolver) ReactToFile(ctx context.Context, fileID string, value int) (*ent.File, error) {
	uid, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, err
	}
	if value != -1 && value != 0 && value != 1 {
		return nil, errors.New("invalid value")
	}
	fr, err := r.Client.FileReaction.Query().Where(filereaction.HasFileWith(file.IDEQ(fileID)), filereaction.UserID(uid)).Only(ctx)
	if value == 0 {
		if err == nil {
			if err := r.Client.FileReaction.DeleteOne(fr).Exec(ctx); err != nil {
				return nil, err
			}
		}
	} else {
		if err == nil {
			if err := r.Client.FileReaction.UpdateOne(fr).SetValue(value).Exec(ctx); err != nil {
				return nil, err
			}
		} else {
			if _, err := r.Client.FileReaction.Create().SetFileID(fileID).SetUserID(uid).SetValue(value).Save(ctx); err != nil {
				return nil, err
			}
		}
	}
	return r.Client.File.Get(ctx, fileID)
}

// GetDownloadURL is the resolver for the getDownloadURL field.
func (r *queryResolver) GetDownloadURL(ctx context.Context, fileID string, ttlSeconds *int) (string, error) {
	start := time.Now()
	f, err := r.Client.File.Query().Where(file.IDEQ(fileID)).Only(ctx)
	if err != nil {
		return "", err
	}
	if f.Quarantine {
		return "", errors.New("file is quarantined")
	}
	if f.Source != "s3" {
		return "", errors.New("file source is not s3")
	}
	ttl := 120
	if ttlSeconds != nil && *ttlSeconds > 0 {
		ttl = *ttlSeconds
	}
	// Rate limit by user/IP && data caps.
	uid, _ := auth.UserID(ctx)
	ip := reqctx.FromContextIP(ctx)
	if r.Rate != nil {
		if err := r.Rate.AllowDownload(uid, ip, f.SizeBytes); err != nil {
			return "", err
		}
	}
	s3c, err := s3client.New(ctx)
	if err != nil {
		return "", err
	}
	url, err := s3c.PresignGet(ctx, f.Path, time.Duration(ttl)*time.Second)
	slog.Info("getDownloadURL", "fileId", fileID, "ttl", ttl, "dur_ms", time.Since(start).Milliseconds())
	return url, err
}

// OpensearchSuggestions is the resolver for the opensearchSuggestions field.
func (r *queryResolver) OpensearchSuggestions(ctx context.Context, q string, platform *game.Platform) ([]string, error) {
	start := time.Now()
	if q == "" {
		return []string{}, nil
	}
	q = strings.TrimSpace(q)
	qb := r.Client.Game.Query()
	qb = qb.Where(func(s *sql.Selector) {
		s.Where(sql.ExprP("to_tsvector('simple', title) @@ plainto_tsquery('simple', ?)", q))
	})
	if platform != nil {
		qb = qb.Where(game.PlatformEQ(*platform))
	}
	titles, err := qb.Limit(10).Unique(true).Select(game.FieldTitle).Strings(ctx)
	if err != nil {
		return nil, err
	}
	slog.Info("opensearchSuggestions", "q", q, "dur_ms", time.Since(start).Milliseconds())
	return titles, nil
}

// PublicSiteConfig is the resolver for the publicSiteConfig field.
func (r *queryResolver) PublicSiteConfig(ctx context.Context) (gqltypes.RawMessage, error) {
	items, err := r.Client.SiteSetting.Query().Where(sitesetting.Public(true)).All(ctx)
	if err != nil {
		return nil, err
	}
	obj := make(map[string]any)
	for _, it := range items {
		var v any
		if len(it.Value) > 0 {
			_ = json.Unmarshal(it.Value, &v)
			obj[it.Key] = v
		}
	}
	b, err := json.Marshal(obj)
	if err != nil {
		return nil, err
	}
	return gqltypes.RawMessage(b), nil
}

// ReportsOpen is the resolver for the reportsOpen field.
func (r *queryResolver) ReportsOpen(ctx context.Context, first *int, offset *int, subjectType *string) ([]*ent.Report, error) {
	lim := 50
	if first != nil && *first > 0 {
		lim = *first
	}
	qb := r.Client.Report.Query().Where(report.StatusEQ(report.StatusOPEN))
	if subjectType != nil && *subjectType != "" {
		qb = qb.Where(report.SubjectTypeEQ(*subjectType))
	}
	if offset != nil && *offset > 0 {
		qb = qb.Offset(*offset)
	}
	return qb.Limit(lim).All(ctx)
}

// ReportsOpenTotal is the resolver for the reportsOpenTotal field.
func (r *queryResolver) ReportsOpenTotal(ctx context.Context, subjectType *string) (int, error) {
	qb := r.Client.Report.Query().Where(report.StatusEQ(report.StatusOPEN))
	if subjectType != nil && *subjectType != "" {
		qb = qb.Where(report.SubjectTypeEQ(*subjectType))
	}
	return qb.Count(ctx)
}

// SearchGames is the resolver for the searchGames field.
func (r *queryResolver) SearchGames(ctx context.Context, q string, platform *game.Platform, yearFrom *int, yearTo *int, format *string, sort *model.SearchSort, first *int, after *entgql.Cursor[string]) (*ent.GameConnection, error) {
	start := time.Now()
	if q == "" {
		return r.Client.Game.Query().Limit(0).Paginate(ctx, nil, first, nil, nil)
	}
	qb := r.Client.Game.Query()
	qb = qb.Where(func(s *sql.Selector) {
		s.Where(sql.ExprP("to_tsvector('simple', title) @@ plainto_tsquery('simple', ?)", q))
	})
	if platform != nil {
		qb = qb.Where(game.PlatformEQ(*platform))
	}
	if yearFrom != nil {
		qb = qb.Where(game.YearGTE(*yearFrom))
	}
	if yearTo != nil {
		qb = qb.Where(game.YearLTE(*yearTo))
	}
	if format != nil && *format != "" {
		qb = qb.Where(game.HasFilesWith(file.FormatEQ(*format)))
	}
	// Order by rank desc, then title asc
	qb = qb.Order(func(s *sql.Selector) {
		s.OrderBy("title ASC")
	})
	var afterCur *entgql.Cursor[string]
	if after != nil {
		c := entgql.Cursor[string](*after)
		afterCur = &c
	}
	res, err := qb.Paginate(ctx, afterCur, first, nil, nil)
	slog.Info("searchGames", "q", q, "dur_ms", time.Since(start).Milliseconds())
	return res, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
