package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/deicod/archivedgames/ent"
	"github.com/deicod/archivedgames/ent/file"
	"github.com/deicod/archivedgames/ent/game"
	"github.com/deicod/archivedgames/ent/image"
	"github.com/deicod/archivedgames/ent/report"
	"github.com/deicod/archivedgames/ent/sitesetting"
	"github.com/deicod/archivedgames/graph/model"
	"github.com/deicod/archivedgames/internal/auth"
	"github.com/deicod/archivedgames/internal/gqltypes"
	"github.com/deicod/archivedgames/internal/imageproc"
	reqctx "github.com/deicod/archivedgames/internal/request"
	"github.com/deicod/archivedgames/internal/s3client"
)

// CreateImageUploads is the resolver for the createImageUploads field.
func (r *mutationResolver) CreateImageUploads(ctx context.Context, gameID string, kind image.Kind, count int) ([]*model.PresignedPut, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return nil, err
	}
	g, err := r.Client.Game.Query().Where(game.IDEQ(gameID)).Only(ctx)
	if err != nil {
		return nil, err
	}
	if count <= 0 || count > 10 {
		count = 1
	}
	s3c, err := s3client.New(ctx)
	if err != nil {
		return nil, err
	}
	now := time.Now().Unix()
	out := make([]*model.PresignedPut, 0, count)
	for i := 0; i < count; i++ {
		key := fmt.Sprintf("images/%s/%d/%d.jpg", g.ID, now, i)
		url, err := s3c.PresignPut(ctx, key, "image/jpeg", 10*time.Minute)
		if err != nil {
			return nil, err
		}
		out = append(out, &model.PresignedPut{Key: key, URL: url})
	}
	return out, nil
}

// FinalizeImageUploads is the resolver for the finalizeImageUploads field.
func (r *mutationResolver) FinalizeImageUploads(ctx context.Context, gameID string, kind image.Kind, items []*model.UploadedImageInput) ([]*ent.Image, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return nil, err
	}
	g, err := r.Client.Game.Query().Where(game.IDEQ(gameID)).Only(ctx)
	if err != nil {
		return nil, err
	}
	created := make([]*ent.Image, 0, len(items))
	for idx, it := range items {
		img, err := r.Client.Image.Create().
			SetGame(g).
			SetKind(kind).
			SetPosition(idx).
			SetS3Key(it.Key).
			SetWidth(it.Width).
			SetHeight(it.Height).
			Save(ctx)
		if err != nil {
			return nil, err
		}
		created = append(created, img)
		// Best-effort derive thumbnails for newly uploaded image
		if s3c, err := s3client.New(ctx); err == nil {
			_ = imageproc.Derive(ctx, s3c, it.Key, []int{128, 512})
		}
	}
	return created, nil
}

// SetSiteSetting is the resolver for the setSiteSetting field.
func (r *mutationResolver) SetSiteSetting(ctx context.Context, key string, value gqltypes.RawMessage, public *bool) (*ent.SiteSetting, error) {
	// Admin guard
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	// Try update
	upd := r.Client.SiteSetting.Update().Where(sitesetting.KeyEQ(key)).SetValue(json.RawMessage(value))
	if public != nil {
		upd = upd.SetPublic(*public)
	}
	if err := upd.Exec(ctx); err == nil {
		return r.Client.SiteSetting.Query().Where(sitesetting.KeyEQ(key)).Only(ctx)
	}
	// Create new
	create := r.Client.SiteSetting.Create().SetKey(key).SetValue(json.RawMessage(value))
	if public != nil {
		create = create.SetPublic(*public)
	}
	return create.Save(ctx)
}

// ReportContent is the resolver for the reportContent field.
func (r *mutationResolver) ReportContent(ctx context.Context, subjectType string, subjectID string, reason string, note *string) (*ent.Report, error) {
	rid, _ := auth.UserID(ctx)
	create := r.Client.Report.Create().SetSubjectType(subjectType).SetSubjectID(subjectID).SetReason(reason)
	if rid != "" {
		create = create.SetReporterID(rid)
	}
	if note != nil {
		create = create.SetNote(*note)
	}
	return create.Save(ctx)
}

// QuarantineFile is the resolver for the quarantineFile field.
func (r *mutationResolver) QuarantineFile(ctx context.Context, fileID string, reason string) (*ent.File, error) {
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	f, err := r.Client.File.Query().Where(file.IDEQ(fileID)).Only(ctx)
	if err != nil {
		return nil, err
	}
	if err := r.Client.File.UpdateOne(f).SetQuarantine(true).Exec(ctx); err != nil {
		return nil, err
	}
	// audit as report actioned
	_, _ = r.Client.Report.Create().SetSubjectType("file").SetSubjectID(fileID).SetReason("quarantine").SetNote(reason).SetStatus("ACTIONED").Save(ctx)
	return r.Client.File.Get(ctx, f.ID)
}

// SetCoverImage is the resolver for the setCoverImage field.
func (r *mutationResolver) SetCoverImage(ctx context.Context, imageID string) (*ent.Image, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return nil, err
	}
	img, err := r.Client.Image.Get(ctx, imageID)
	if err != nil {
		return nil, err
	}
	gID, err := r.Client.Image.Query().Where(image.IDEQ(imageID)).QueryGame().OnlyID(ctx)
	if err != nil {
		return nil, err
	}
	if err := r.Client.Image.Update().Where(image.HasGameWith(game.IDEQ(gID)), image.KindEQ(image.KindCOVER)).SetKind(image.KindGALLERY).Exec(ctx); err != nil {
		return nil, err
	}
	if err := r.Client.Image.UpdateOne(img).SetKind(image.KindCOVER).SetPosition(0).Exec(ctx); err != nil {
		return nil, err
	}
	return r.Client.Image.Get(ctx, imageID)
}

// DeleteImage is the resolver for the deleteImage field.
func (r *mutationResolver) DeleteImage(ctx context.Context, imageID string) (bool, error) {
	if _, err := auth.RequireUser(ctx); err != nil {
		return false, err
	}
	if err := r.Client.Image.DeleteOneID(imageID).Exec(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// SetReportStatus is the resolver for the setReportStatus field.
func (r *mutationResolver) SetReportStatus(ctx context.Context, reportID string, status report.Status, note *string) (*ent.Report, error) {
	// Admin guard
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	// Fetch current and update with optional admin note
	rep, err := r.Client.Report.Get(ctx, reportID)
	if err != nil {
		return nil, err
	}
	upd := r.Client.Report.UpdateOneID(reportID).SetStatus(status)
	if note != nil && *note != "" {
		merged := rep.Note
		if merged != "" {
			merged += " | "
		}
		merged += "admin: " + *note
		upd = upd.SetNote(merged)
	}
	if err := upd.Exec(ctx); err != nil {
		return nil, err
	}
	return r.Client.Report.Get(ctx, reportID)
}

// SetReportStatusBulk is the resolver for the setReportStatusBulk field.
func (r *mutationResolver) SetReportStatusBulk(ctx context.Context, reportIds []string, status report.Status, note *string) ([]*ent.Report, error) {
	isAdmin := false
	for _, ro := range auth.Roles(ctx) {
		if ro == "admin" {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return nil, errors.New("forbidden")
	}
	out := make([]*ent.Report, 0, len(reportIds))
	for _, id := range reportIds {
		rep, err := r.SetReportStatus(ctx, id, status, note)
		if err != nil {
			return nil, err
		}
		out = append(out, rep)
	}
	return out, nil
}

// GetDownloadURL is the resolver for the getDownloadURL field.
func (r *queryResolver) GetDownloadURL(ctx context.Context, fileID string, ttlSeconds *int) (string, error) {
	f, err := r.Client.File.Query().Where(file.IDEQ(fileID)).Only(ctx)
	if err != nil {
		return "", err
	}
	if f.Quarantine {
		return "", errors.New("file is quarantined")
	}
	if f.Source != "s3" {
		return "", errors.New("file source is not s3")
	}
	ttl := 120
	if ttlSeconds != nil && *ttlSeconds > 0 {
		ttl = *ttlSeconds
	}
	// Rate limit by user/IP && data caps.
	uid, _ := auth.UserID(ctx)
	ip := reqctx.FromContextIP(ctx)
	if r.Rate != nil {
		if err := r.Rate.AllowDownload(uid, ip, f.SizeBytes); err != nil {
			return "", err
		}
	}
	s3c, err := s3client.New(ctx)
	if err != nil {
		return "", err
	}
	return s3c.PresignGet(ctx, f.Path, time.Duration(ttl)*time.Second)
}

// OpensearchSuggestions is the resolver for the opensearchSuggestions field.
func (r *queryResolver) OpensearchSuggestions(ctx context.Context, q string, platform *game.Platform) ([]string, error) {
	if q == "" {
		return []string{}, nil
	}
	q = strings.TrimSpace(q)
	qb := r.Client.Game.Query().Where(game.TitleContainsFold(q))
	if platform != nil {
		qb = qb.Where(game.PlatformEQ(*platform))
	}
	titles, err := qb.Limit(10).Unique(true).Select(game.FieldTitle).Strings(ctx)
	if err != nil {
		return nil, err
	}
	return titles, nil
}

// PublicSiteConfig is the resolver for the publicSiteConfig field.
func (r *queryResolver) PublicSiteConfig(ctx context.Context) (gqltypes.RawMessage, error) {
	items, err := r.Client.SiteSetting.Query().Where(sitesetting.Public(true)).All(ctx)
	if err != nil {
		return nil, err
	}
	obj := make(map[string]any)
	for _, it := range items {
		var v any
		if len(it.Value) > 0 {
			_ = json.Unmarshal(it.Value, &v)
			obj[it.Key] = v
		}
	}
	b, err := json.Marshal(obj)
	if err != nil {
		return nil, err
	}
	return gqltypes.RawMessage(b), nil
}

// ReportsOpen is the resolver for the reportsOpen field.
func (r *queryResolver) ReportsOpen(ctx context.Context, first *int, offset *int, subjectType *string) ([]*ent.Report, error) {
	lim := 50
	if first != nil && *first > 0 {
		lim = *first
	}
	qb := r.Client.Report.Query().Where(report.StatusEQ(report.StatusOPEN))
	if subjectType != nil && *subjectType != "" {
		qb = qb.Where(report.SubjectTypeEQ(*subjectType))
	}
	if offset != nil && *offset > 0 {
		qb = qb.Offset(*offset)
	}
	return qb.Limit(lim).All(ctx)
}

// ReportsOpenTotal is the resolver for the reportsOpenTotal field.
func (r *queryResolver) ReportsOpenTotal(ctx context.Context, subjectType *string) (int, error) {
	qb := r.Client.Report.Query().Where(report.StatusEQ(report.StatusOPEN))
	if subjectType != nil && *subjectType != "" {
		qb = qb.Where(report.SubjectTypeEQ(*subjectType))
	}
	return qb.Count(ctx)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
