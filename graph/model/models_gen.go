// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/deicod/archivedgames/ent/game"
	"github.com/deicod/archivedgames/ent/image"
	"github.com/deicod/archivedgames/ent/report"
)

// CommentWhereInput is used for filtering Comment objects.
// Input was generated by ent.
type CommentWhereInput struct {
	Not *CommentWhereInput   `json:"not,omitempty"`
	And []*CommentWhereInput `json:"and,omitempty"`
	Or  []*CommentWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// subject_type field predicates
	SubjectType             *string  `json:"subjectType,omitempty"`
	SubjectTypeNeq          *string  `json:"subjectTypeNEQ,omitempty"`
	SubjectTypeIn           []string `json:"subjectTypeIn,omitempty"`
	SubjectTypeNotIn        []string `json:"subjectTypeNotIn,omitempty"`
	SubjectTypeGt           *string  `json:"subjectTypeGT,omitempty"`
	SubjectTypeGte          *string  `json:"subjectTypeGTE,omitempty"`
	SubjectTypeLt           *string  `json:"subjectTypeLT,omitempty"`
	SubjectTypeLte          *string  `json:"subjectTypeLTE,omitempty"`
	SubjectTypeContains     *string  `json:"subjectTypeContains,omitempty"`
	SubjectTypeHasPrefix    *string  `json:"subjectTypeHasPrefix,omitempty"`
	SubjectTypeHasSuffix    *string  `json:"subjectTypeHasSuffix,omitempty"`
	SubjectTypeEqualFold    *string  `json:"subjectTypeEqualFold,omitempty"`
	SubjectTypeContainsFold *string  `json:"subjectTypeContainsFold,omitempty"`
	// subject_id field predicates
	SubjectID             *string  `json:"subjectID,omitempty"`
	SubjectIdneq          *string  `json:"subjectIDNEQ,omitempty"`
	SubjectIDIn           []string `json:"subjectIDIn,omitempty"`
	SubjectIDNotIn        []string `json:"subjectIDNotIn,omitempty"`
	SubjectIdgt           *string  `json:"subjectIDGT,omitempty"`
	SubjectIdgte          *string  `json:"subjectIDGTE,omitempty"`
	SubjectIdlt           *string  `json:"subjectIDLT,omitempty"`
	SubjectIdlte          *string  `json:"subjectIDLTE,omitempty"`
	SubjectIDContains     *string  `json:"subjectIDContains,omitempty"`
	SubjectIDHasPrefix    *string  `json:"subjectIDHasPrefix,omitempty"`
	SubjectIDHasSuffix    *string  `json:"subjectIDHasSuffix,omitempty"`
	SubjectIDEqualFold    *string  `json:"subjectIDEqualFold,omitempty"`
	SubjectIDContainsFold *string  `json:"subjectIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// language field predicates
	Language             *string  `json:"language,omitempty"`
	LanguageNeq          *string  `json:"languageNEQ,omitempty"`
	LanguageIn           []string `json:"languageIn,omitempty"`
	LanguageNotIn        []string `json:"languageNotIn,omitempty"`
	LanguageGt           *string  `json:"languageGT,omitempty"`
	LanguageGte          *string  `json:"languageGTE,omitempty"`
	LanguageLt           *string  `json:"languageLT,omitempty"`
	LanguageLte          *string  `json:"languageLTE,omitempty"`
	LanguageContains     *string  `json:"languageContains,omitempty"`
	LanguageHasPrefix    *string  `json:"languageHasPrefix,omitempty"`
	LanguageHasSuffix    *string  `json:"languageHasSuffix,omitempty"`
	LanguageIsNil        *bool    `json:"languageIsNil,omitempty"`
	LanguageNotNil       *bool    `json:"languageNotNil,omitempty"`
	LanguageEqualFold    *string  `json:"languageEqualFold,omitempty"`
	LanguageContainsFold *string  `json:"languageContainsFold,omitempty"`
	// content_sanitized field predicates
	ContentSanitized             *string  `json:"contentSanitized,omitempty"`
	ContentSanitizedNeq          *string  `json:"contentSanitizedNEQ,omitempty"`
	ContentSanitizedIn           []string `json:"contentSanitizedIn,omitempty"`
	ContentSanitizedNotIn        []string `json:"contentSanitizedNotIn,omitempty"`
	ContentSanitizedGt           *string  `json:"contentSanitizedGT,omitempty"`
	ContentSanitizedGte          *string  `json:"contentSanitizedGTE,omitempty"`
	ContentSanitizedLt           *string  `json:"contentSanitizedLT,omitempty"`
	ContentSanitizedLte          *string  `json:"contentSanitizedLTE,omitempty"`
	ContentSanitizedContains     *string  `json:"contentSanitizedContains,omitempty"`
	ContentSanitizedHasPrefix    *string  `json:"contentSanitizedHasPrefix,omitempty"`
	ContentSanitizedHasSuffix    *string  `json:"contentSanitizedHasSuffix,omitempty"`
	ContentSanitizedEqualFold    *string  `json:"contentSanitizedEqualFold,omitempty"`
	ContentSanitizedContainsFold *string  `json:"contentSanitizedContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// edited_at field predicates
	EditedAt       *time.Time   `json:"editedAt,omitempty"`
	EditedAtNeq    *time.Time   `json:"editedAtNEQ,omitempty"`
	EditedAtIn     []*time.Time `json:"editedAtIn,omitempty"`
	EditedAtNotIn  []*time.Time `json:"editedAtNotIn,omitempty"`
	EditedAtGt     *time.Time   `json:"editedAtGT,omitempty"`
	EditedAtGte    *time.Time   `json:"editedAtGTE,omitempty"`
	EditedAtLt     *time.Time   `json:"editedAtLT,omitempty"`
	EditedAtLte    *time.Time   `json:"editedAtLTE,omitempty"`
	EditedAtIsNil  *bool        `json:"editedAtIsNil,omitempty"`
	EditedAtNotNil *bool        `json:"editedAtNotNil,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// game edge predicates
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// FileGroupWhereInput is used for filtering FileGroup objects.
// Input was generated by ent.
type FileGroupWhereInput struct {
	Not *FileGroupWhereInput   `json:"not,omitempty"`
	And []*FileGroupWhereInput `json:"and,omitempty"`
	Or  []*FileGroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// key field predicates
	Key             *string  `json:"key,omitempty"`
	KeyNeq          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGt           *string  `json:"keyGT,omitempty"`
	KeyGte          *string  `json:"keyGTE,omitempty"`
	KeyLt           *string  `json:"keyLT,omitempty"`
	KeyLte          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// game edge predicates
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
}

// FileReactionWhereInput is used for filtering FileReaction objects.
// Input was generated by ent.
type FileReactionWhereInput struct {
	Not *FileReactionWhereInput   `json:"not,omitempty"`
	And []*FileReactionWhereInput `json:"and,omitempty"`
	Or  []*FileReactionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// value field predicates
	Value      *int  `json:"value,omitempty"`
	ValueNeq   *int  `json:"valueNEQ,omitempty"`
	ValueIn    []int `json:"valueIn,omitempty"`
	ValueNotIn []int `json:"valueNotIn,omitempty"`
	ValueGt    *int  `json:"valueGT,omitempty"`
	ValueGte   *int  `json:"valueGTE,omitempty"`
	ValueLt    *int  `json:"valueLT,omitempty"`
	ValueLte   *int  `json:"valueLTE,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// FileWhereInput is used for filtering File objects.
// Input was generated by ent.
type FileWhereInput struct {
	Not *FileWhereInput   `json:"not,omitempty"`
	And []*FileWhereInput `json:"and,omitempty"`
	Or  []*FileWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// path field predicates
	Path             *string  `json:"path,omitempty"`
	PathNeq          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGt           *string  `json:"pathGT,omitempty"`
	PathGte          *string  `json:"pathGTE,omitempty"`
	PathLt           *string  `json:"pathLT,omitempty"`
	PathLte          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`
	// original_name field predicates
	OriginalName             *string  `json:"originalName,omitempty"`
	OriginalNameNeq          *string  `json:"originalNameNEQ,omitempty"`
	OriginalNameIn           []string `json:"originalNameIn,omitempty"`
	OriginalNameNotIn        []string `json:"originalNameNotIn,omitempty"`
	OriginalNameGt           *string  `json:"originalNameGT,omitempty"`
	OriginalNameGte          *string  `json:"originalNameGTE,omitempty"`
	OriginalNameLt           *string  `json:"originalNameLT,omitempty"`
	OriginalNameLte          *string  `json:"originalNameLTE,omitempty"`
	OriginalNameContains     *string  `json:"originalNameContains,omitempty"`
	OriginalNameHasPrefix    *string  `json:"originalNameHasPrefix,omitempty"`
	OriginalNameHasSuffix    *string  `json:"originalNameHasSuffix,omitempty"`
	OriginalNameEqualFold    *string  `json:"originalNameEqualFold,omitempty"`
	OriginalNameContainsFold *string  `json:"originalNameContainsFold,omitempty"`
	// normalized_name field predicates
	NormalizedName             *string  `json:"normalizedName,omitempty"`
	NormalizedNameNeq          *string  `json:"normalizedNameNEQ,omitempty"`
	NormalizedNameIn           []string `json:"normalizedNameIn,omitempty"`
	NormalizedNameNotIn        []string `json:"normalizedNameNotIn,omitempty"`
	NormalizedNameGt           *string  `json:"normalizedNameGT,omitempty"`
	NormalizedNameGte          *string  `json:"normalizedNameGTE,omitempty"`
	NormalizedNameLt           *string  `json:"normalizedNameLT,omitempty"`
	NormalizedNameLte          *string  `json:"normalizedNameLTE,omitempty"`
	NormalizedNameContains     *string  `json:"normalizedNameContains,omitempty"`
	NormalizedNameHasPrefix    *string  `json:"normalizedNameHasPrefix,omitempty"`
	NormalizedNameHasSuffix    *string  `json:"normalizedNameHasSuffix,omitempty"`
	NormalizedNameEqualFold    *string  `json:"normalizedNameEqualFold,omitempty"`
	NormalizedNameContainsFold *string  `json:"normalizedNameContainsFold,omitempty"`
	// set_key field predicates
	SetKey             *string  `json:"setKey,omitempty"`
	SetKeyNeq          *string  `json:"setKeyNEQ,omitempty"`
	SetKeyIn           []string `json:"setKeyIn,omitempty"`
	SetKeyNotIn        []string `json:"setKeyNotIn,omitempty"`
	SetKeyGt           *string  `json:"setKeyGT,omitempty"`
	SetKeyGte          *string  `json:"setKeyGTE,omitempty"`
	SetKeyLt           *string  `json:"setKeyLT,omitempty"`
	SetKeyLte          *string  `json:"setKeyLTE,omitempty"`
	SetKeyContains     *string  `json:"setKeyContains,omitempty"`
	SetKeyHasPrefix    *string  `json:"setKeyHasPrefix,omitempty"`
	SetKeyHasSuffix    *string  `json:"setKeyHasSuffix,omitempty"`
	SetKeyIsNil        *bool    `json:"setKeyIsNil,omitempty"`
	SetKeyNotNil       *bool    `json:"setKeyNotNil,omitempty"`
	SetKeyEqualFold    *string  `json:"setKeyEqualFold,omitempty"`
	SetKeyContainsFold *string  `json:"setKeyContainsFold,omitempty"`
	// checksum field predicates
	Checksum             *string  `json:"checksum,omitempty"`
	ChecksumNeq          *string  `json:"checksumNEQ,omitempty"`
	ChecksumIn           []string `json:"checksumIn,omitempty"`
	ChecksumNotIn        []string `json:"checksumNotIn,omitempty"`
	ChecksumGt           *string  `json:"checksumGT,omitempty"`
	ChecksumGte          *string  `json:"checksumGTE,omitempty"`
	ChecksumLt           *string  `json:"checksumLT,omitempty"`
	ChecksumLte          *string  `json:"checksumLTE,omitempty"`
	ChecksumContains     *string  `json:"checksumContains,omitempty"`
	ChecksumHasPrefix    *string  `json:"checksumHasPrefix,omitempty"`
	ChecksumHasSuffix    *string  `json:"checksumHasSuffix,omitempty"`
	ChecksumEqualFold    *string  `json:"checksumEqualFold,omitempty"`
	ChecksumContainsFold *string  `json:"checksumContainsFold,omitempty"`
	// size_bytes field predicates
	SizeBytes      *int  `json:"sizeBytes,omitempty"`
	SizeBytesNeq   *int  `json:"sizeBytesNEQ,omitempty"`
	SizeBytesIn    []int `json:"sizeBytesIn,omitempty"`
	SizeBytesNotIn []int `json:"sizeBytesNotIn,omitempty"`
	SizeBytesGt    *int  `json:"sizeBytesGT,omitempty"`
	SizeBytesGte   *int  `json:"sizeBytesGTE,omitempty"`
	SizeBytesLt    *int  `json:"sizeBytesLT,omitempty"`
	SizeBytesLte   *int  `json:"sizeBytesLTE,omitempty"`
	// mime_type field predicates
	MimeType             *string  `json:"mimeType,omitempty"`
	MimeTypeNeq          *string  `json:"mimeTypeNEQ,omitempty"`
	MimeTypeIn           []string `json:"mimeTypeIn,omitempty"`
	MimeTypeNotIn        []string `json:"mimeTypeNotIn,omitempty"`
	MimeTypeGt           *string  `json:"mimeTypeGT,omitempty"`
	MimeTypeGte          *string  `json:"mimeTypeGTE,omitempty"`
	MimeTypeLt           *string  `json:"mimeTypeLT,omitempty"`
	MimeTypeLte          *string  `json:"mimeTypeLTE,omitempty"`
	MimeTypeContains     *string  `json:"mimeTypeContains,omitempty"`
	MimeTypeHasPrefix    *string  `json:"mimeTypeHasPrefix,omitempty"`
	MimeTypeHasSuffix    *string  `json:"mimeTypeHasSuffix,omitempty"`
	MimeTypeIsNil        *bool    `json:"mimeTypeIsNil,omitempty"`
	MimeTypeNotNil       *bool    `json:"mimeTypeNotNil,omitempty"`
	MimeTypeEqualFold    *string  `json:"mimeTypeEqualFold,omitempty"`
	MimeTypeContainsFold *string  `json:"mimeTypeContainsFold,omitempty"`
	// format field predicates
	Format             *string  `json:"format,omitempty"`
	FormatNeq          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGt           *string  `json:"formatGT,omitempty"`
	FormatGte          *string  `json:"formatGTE,omitempty"`
	FormatLt           *string  `json:"formatLT,omitempty"`
	FormatLte          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatIsNil        *bool    `json:"formatIsNil,omitempty"`
	FormatNotNil       *bool    `json:"formatNotNil,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// quarantine field predicates
	Quarantine    *bool `json:"quarantine,omitempty"`
	QuarantineNeq *bool `json:"quarantineNEQ,omitempty"`
	// needs_review field predicates
	NeedsReview    *bool `json:"needsReview,omitempty"`
	NeedsReviewNeq *bool `json:"needsReviewNEQ,omitempty"`
	// disk_number field predicates
	DiskNumber       *int  `json:"diskNumber,omitempty"`
	DiskNumberNeq    *int  `json:"diskNumberNEQ,omitempty"`
	DiskNumberIn     []int `json:"diskNumberIn,omitempty"`
	DiskNumberNotIn  []int `json:"diskNumberNotIn,omitempty"`
	DiskNumberGt     *int  `json:"diskNumberGT,omitempty"`
	DiskNumberGte    *int  `json:"diskNumberGTE,omitempty"`
	DiskNumberLt     *int  `json:"diskNumberLT,omitempty"`
	DiskNumberLte    *int  `json:"diskNumberLTE,omitempty"`
	DiskNumberIsNil  *bool `json:"diskNumberIsNil,omitempty"`
	DiskNumberNotNil *bool `json:"diskNumberNotNil,omitempty"`
	// side field predicates
	Side             *string  `json:"side,omitempty"`
	SideNeq          *string  `json:"sideNEQ,omitempty"`
	SideIn           []string `json:"sideIn,omitempty"`
	SideNotIn        []string `json:"sideNotIn,omitempty"`
	SideGt           *string  `json:"sideGT,omitempty"`
	SideGte          *string  `json:"sideGTE,omitempty"`
	SideLt           *string  `json:"sideLT,omitempty"`
	SideLte          *string  `json:"sideLTE,omitempty"`
	SideContains     *string  `json:"sideContains,omitempty"`
	SideHasPrefix    *string  `json:"sideHasPrefix,omitempty"`
	SideHasSuffix    *string  `json:"sideHasSuffix,omitempty"`
	SideIsNil        *bool    `json:"sideIsNil,omitempty"`
	SideNotNil       *bool    `json:"sideNotNil,omitempty"`
	SideEqualFold    *string  `json:"sideEqualFold,omitempty"`
	SideContainsFold *string  `json:"sideContainsFold,omitempty"`
	// game edge predicates
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
	// group edge predicates
	HasGroup     *bool                  `json:"hasGroup,omitempty"`
	HasGroupWith []*FileGroupWhereInput `json:"hasGroupWith,omitempty"`
	// comments edge predicates
	HasComments     *bool                `json:"hasComments,omitempty"`
	HasCommentsWith []*CommentWhereInput `json:"hasCommentsWith,omitempty"`
	// reactions edge predicates
	HasReactions     *bool                     `json:"hasReactions,omitempty"`
	HasReactionsWith []*FileReactionWhereInput `json:"hasReactionsWith,omitempty"`
}

// GameLikeWhereInput is used for filtering GameLike objects.
// Input was generated by ent.
type GameLikeWhereInput struct {
	Not *GameLikeWhereInput   `json:"not,omitempty"`
	And []*GameLikeWhereInput `json:"and,omitempty"`
	Or  []*GameLikeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// game edge predicates
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
}

// GameWhereInput is used for filtering Game objects.
// Input was generated by ent.
type GameWhereInput struct {
	Not *GameWhereInput   `json:"not,omitempty"`
	And []*GameWhereInput `json:"and,omitempty"`
	Or  []*GameWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// slug field predicates
	Slug             *string  `json:"slug,omitempty"`
	SlugNeq          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGt           *string  `json:"slugGT,omitempty"`
	SlugGte          *string  `json:"slugGTE,omitempty"`
	SlugLt           *string  `json:"slugLT,omitempty"`
	SlugLte          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`
	// platform field predicates
	Platform      *game.Platform  `json:"platform,omitempty"`
	PlatformNeq   *game.Platform  `json:"platformNEQ,omitempty"`
	PlatformIn    []game.Platform `json:"platformIn,omitempty"`
	PlatformNotIn []game.Platform `json:"platformNotIn,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// year field predicates
	Year       *int  `json:"year,omitempty"`
	YearNeq    *int  `json:"yearNEQ,omitempty"`
	YearIn     []int `json:"yearIn,omitempty"`
	YearNotIn  []int `json:"yearNotIn,omitempty"`
	YearGt     *int  `json:"yearGT,omitempty"`
	YearGte    *int  `json:"yearGTE,omitempty"`
	YearLt     *int  `json:"yearLT,omitempty"`
	YearLte    *int  `json:"yearLTE,omitempty"`
	YearIsNil  *bool `json:"yearIsNil,omitempty"`
	YearNotNil *bool `json:"yearNotNil,omitempty"`
	// publisher field predicates
	Publisher             *string  `json:"publisher,omitempty"`
	PublisherNeq          *string  `json:"publisherNEQ,omitempty"`
	PublisherIn           []string `json:"publisherIn,omitempty"`
	PublisherNotIn        []string `json:"publisherNotIn,omitempty"`
	PublisherGt           *string  `json:"publisherGT,omitempty"`
	PublisherGte          *string  `json:"publisherGTE,omitempty"`
	PublisherLt           *string  `json:"publisherLT,omitempty"`
	PublisherLte          *string  `json:"publisherLTE,omitempty"`
	PublisherContains     *string  `json:"publisherContains,omitempty"`
	PublisherHasPrefix    *string  `json:"publisherHasPrefix,omitempty"`
	PublisherHasSuffix    *string  `json:"publisherHasSuffix,omitempty"`
	PublisherIsNil        *bool    `json:"publisherIsNil,omitempty"`
	PublisherNotNil       *bool    `json:"publisherNotNil,omitempty"`
	PublisherEqualFold    *string  `json:"publisherEqualFold,omitempty"`
	PublisherContainsFold *string  `json:"publisherContainsFold,omitempty"`
	// developer field predicates
	Developer             *string  `json:"developer,omitempty"`
	DeveloperNeq          *string  `json:"developerNEQ,omitempty"`
	DeveloperIn           []string `json:"developerIn,omitempty"`
	DeveloperNotIn        []string `json:"developerNotIn,omitempty"`
	DeveloperGt           *string  `json:"developerGT,omitempty"`
	DeveloperGte          *string  `json:"developerGTE,omitempty"`
	DeveloperLt           *string  `json:"developerLT,omitempty"`
	DeveloperLte          *string  `json:"developerLTE,omitempty"`
	DeveloperContains     *string  `json:"developerContains,omitempty"`
	DeveloperHasPrefix    *string  `json:"developerHasPrefix,omitempty"`
	DeveloperHasSuffix    *string  `json:"developerHasSuffix,omitempty"`
	DeveloperIsNil        *bool    `json:"developerIsNil,omitempty"`
	DeveloperNotNil       *bool    `json:"developerNotNil,omitempty"`
	DeveloperEqualFold    *string  `json:"developerEqualFold,omitempty"`
	DeveloperContainsFold *string  `json:"developerContainsFold,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// images edge predicates
	HasImages     *bool              `json:"hasImages,omitempty"`
	HasImagesWith []*ImageWhereInput `json:"hasImagesWith,omitempty"`
	// comments edge predicates
	HasComments     *bool                `json:"hasComments,omitempty"`
	HasCommentsWith []*CommentWhereInput `json:"hasCommentsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool                  `json:"hasGroups,omitempty"`
	HasGroupsWith []*FileGroupWhereInput `json:"hasGroupsWith,omitempty"`
	// likes edge predicates
	HasLikes     *bool                 `json:"hasLikes,omitempty"`
	HasLikesWith []*GameLikeWhereInput `json:"hasLikesWith,omitempty"`
}

// ImageWhereInput is used for filtering Image objects.
// Input was generated by ent.
type ImageWhereInput struct {
	Not *ImageWhereInput   `json:"not,omitempty"`
	And []*ImageWhereInput `json:"and,omitempty"`
	Or  []*ImageWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// kind field predicates
	Kind      *image.Kind  `json:"kind,omitempty"`
	KindNeq   *image.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []image.Kind `json:"kindIn,omitempty"`
	KindNotIn []image.Kind `json:"kindNotIn,omitempty"`
	// position field predicates
	Position      *int  `json:"position,omitempty"`
	PositionNeq   *int  `json:"positionNEQ,omitempty"`
	PositionIn    []int `json:"positionIn,omitempty"`
	PositionNotIn []int `json:"positionNotIn,omitempty"`
	PositionGt    *int  `json:"positionGT,omitempty"`
	PositionGte   *int  `json:"positionGTE,omitempty"`
	PositionLt    *int  `json:"positionLT,omitempty"`
	PositionLte   *int  `json:"positionLTE,omitempty"`
	// s3_key field predicates
	S3Key             *string  `json:"s3Key,omitempty"`
	S3KeyNeq          *string  `json:"s3KeyNEQ,omitempty"`
	S3KeyIn           []string `json:"s3KeyIn,omitempty"`
	S3KeyNotIn        []string `json:"s3KeyNotIn,omitempty"`
	S3KeyGt           *string  `json:"s3KeyGT,omitempty"`
	S3KeyGte          *string  `json:"s3KeyGTE,omitempty"`
	S3KeyLt           *string  `json:"s3KeyLT,omitempty"`
	S3KeyLte          *string  `json:"s3KeyLTE,omitempty"`
	S3KeyContains     *string  `json:"s3KeyContains,omitempty"`
	S3KeyHasPrefix    *string  `json:"s3KeyHasPrefix,omitempty"`
	S3KeyHasSuffix    *string  `json:"s3KeyHasSuffix,omitempty"`
	S3KeyEqualFold    *string  `json:"s3KeyEqualFold,omitempty"`
	S3KeyContainsFold *string  `json:"s3KeyContainsFold,omitempty"`
	// width field predicates
	Width      *int  `json:"width,omitempty"`
	WidthNeq   *int  `json:"widthNEQ,omitempty"`
	WidthIn    []int `json:"widthIn,omitempty"`
	WidthNotIn []int `json:"widthNotIn,omitempty"`
	WidthGt    *int  `json:"widthGT,omitempty"`
	WidthGte   *int  `json:"widthGTE,omitempty"`
	WidthLt    *int  `json:"widthLT,omitempty"`
	WidthLte   *int  `json:"widthLTE,omitempty"`
	// height field predicates
	Height      *int  `json:"height,omitempty"`
	HeightNeq   *int  `json:"heightNEQ,omitempty"`
	HeightIn    []int `json:"heightIn,omitempty"`
	HeightNotIn []int `json:"heightNotIn,omitempty"`
	HeightGt    *int  `json:"heightGT,omitempty"`
	HeightGte   *int  `json:"heightGTE,omitempty"`
	HeightLt    *int  `json:"heightLT,omitempty"`
	HeightLte   *int  `json:"heightLTE,omitempty"`
	// game edge predicates
	HasGame     *bool             `json:"hasGame,omitempty"`
	HasGameWith []*GameWhereInput `json:"hasGameWith,omitempty"`
}

type Mutation struct {
}

type PresignedPut struct {
	Key string `json:"key"`
	URL string `json:"url"`
}

type Query struct {
}

type ReactionSummary struct {
	Up     int `json:"up"`
	Down   int `json:"down"`
	Viewer int `json:"viewer"`
}

// ReportWhereInput is used for filtering Report objects.
// Input was generated by ent.
type ReportWhereInput struct {
	Not *ReportWhereInput   `json:"not,omitempty"`
	And []*ReportWhereInput `json:"and,omitempty"`
	Or  []*ReportWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// subject_type field predicates
	SubjectType             *string  `json:"subjectType,omitempty"`
	SubjectTypeNeq          *string  `json:"subjectTypeNEQ,omitempty"`
	SubjectTypeIn           []string `json:"subjectTypeIn,omitempty"`
	SubjectTypeNotIn        []string `json:"subjectTypeNotIn,omitempty"`
	SubjectTypeGt           *string  `json:"subjectTypeGT,omitempty"`
	SubjectTypeGte          *string  `json:"subjectTypeGTE,omitempty"`
	SubjectTypeLt           *string  `json:"subjectTypeLT,omitempty"`
	SubjectTypeLte          *string  `json:"subjectTypeLTE,omitempty"`
	SubjectTypeContains     *string  `json:"subjectTypeContains,omitempty"`
	SubjectTypeHasPrefix    *string  `json:"subjectTypeHasPrefix,omitempty"`
	SubjectTypeHasSuffix    *string  `json:"subjectTypeHasSuffix,omitempty"`
	SubjectTypeEqualFold    *string  `json:"subjectTypeEqualFold,omitempty"`
	SubjectTypeContainsFold *string  `json:"subjectTypeContainsFold,omitempty"`
	// subject_id field predicates
	SubjectID             *string  `json:"subjectID,omitempty"`
	SubjectIdneq          *string  `json:"subjectIDNEQ,omitempty"`
	SubjectIDIn           []string `json:"subjectIDIn,omitempty"`
	SubjectIDNotIn        []string `json:"subjectIDNotIn,omitempty"`
	SubjectIdgt           *string  `json:"subjectIDGT,omitempty"`
	SubjectIdgte          *string  `json:"subjectIDGTE,omitempty"`
	SubjectIdlt           *string  `json:"subjectIDLT,omitempty"`
	SubjectIdlte          *string  `json:"subjectIDLTE,omitempty"`
	SubjectIDContains     *string  `json:"subjectIDContains,omitempty"`
	SubjectIDHasPrefix    *string  `json:"subjectIDHasPrefix,omitempty"`
	SubjectIDHasSuffix    *string  `json:"subjectIDHasSuffix,omitempty"`
	SubjectIDEqualFold    *string  `json:"subjectIDEqualFold,omitempty"`
	SubjectIDContainsFold *string  `json:"subjectIDContainsFold,omitempty"`
	// reporter_id field predicates
	ReporterID             *string  `json:"reporterID,omitempty"`
	ReporterIdneq          *string  `json:"reporterIDNEQ,omitempty"`
	ReporterIDIn           []string `json:"reporterIDIn,omitempty"`
	ReporterIDNotIn        []string `json:"reporterIDNotIn,omitempty"`
	ReporterIdgt           *string  `json:"reporterIDGT,omitempty"`
	ReporterIdgte          *string  `json:"reporterIDGTE,omitempty"`
	ReporterIdlt           *string  `json:"reporterIDLT,omitempty"`
	ReporterIdlte          *string  `json:"reporterIDLTE,omitempty"`
	ReporterIDContains     *string  `json:"reporterIDContains,omitempty"`
	ReporterIDHasPrefix    *string  `json:"reporterIDHasPrefix,omitempty"`
	ReporterIDHasSuffix    *string  `json:"reporterIDHasSuffix,omitempty"`
	ReporterIDIsNil        *bool    `json:"reporterIDIsNil,omitempty"`
	ReporterIDNotNil       *bool    `json:"reporterIDNotNil,omitempty"`
	ReporterIDEqualFold    *string  `json:"reporterIDEqualFold,omitempty"`
	ReporterIDContainsFold *string  `json:"reporterIDContainsFold,omitempty"`
	// reason field predicates
	Reason             *string  `json:"reason,omitempty"`
	ReasonNeq          *string  `json:"reasonNEQ,omitempty"`
	ReasonIn           []string `json:"reasonIn,omitempty"`
	ReasonNotIn        []string `json:"reasonNotIn,omitempty"`
	ReasonGt           *string  `json:"reasonGT,omitempty"`
	ReasonGte          *string  `json:"reasonGTE,omitempty"`
	ReasonLt           *string  `json:"reasonLT,omitempty"`
	ReasonLte          *string  `json:"reasonLTE,omitempty"`
	ReasonContains     *string  `json:"reasonContains,omitempty"`
	ReasonHasPrefix    *string  `json:"reasonHasPrefix,omitempty"`
	ReasonHasSuffix    *string  `json:"reasonHasSuffix,omitempty"`
	ReasonEqualFold    *string  `json:"reasonEqualFold,omitempty"`
	ReasonContainsFold *string  `json:"reasonContainsFold,omitempty"`
	// note field predicates
	Note             *string  `json:"note,omitempty"`
	NoteNeq          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGt           *string  `json:"noteGT,omitempty"`
	NoteGte          *string  `json:"noteGTE,omitempty"`
	NoteLt           *string  `json:"noteLT,omitempty"`
	NoteLte          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        *bool    `json:"noteIsNil,omitempty"`
	NoteNotNil       *bool    `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`
	// status field predicates
	Status      *report.Status  `json:"status,omitempty"`
	StatusNeq   *report.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []report.Status `json:"statusIn,omitempty"`
	StatusNotIn []report.Status `json:"statusNotIn,omitempty"`
}

// SiteSettingWhereInput is used for filtering SiteSetting objects.
// Input was generated by ent.
type SiteSettingWhereInput struct {
	Not *SiteSettingWhereInput   `json:"not,omitempty"`
	And []*SiteSettingWhereInput `json:"and,omitempty"`
	Or  []*SiteSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// key field predicates
	Key             *string  `json:"key,omitempty"`
	KeyNeq          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGt           *string  `json:"keyGT,omitempty"`
	KeyGte          *string  `json:"keyGTE,omitempty"`
	KeyLt           *string  `json:"keyLT,omitempty"`
	KeyLte          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`
	// public field predicates
	Public    *bool `json:"public,omitempty"`
	PublicNeq *bool `json:"publicNEQ,omitempty"`
}

type UploadedImageInput struct {
	Key    string `json:"key"`
	Width  int    `json:"width"`
	Height int    `json:"height"`
}

type UserShadow struct {
	ID          string  `json:"id"`
	KeycloakSub string  `json:"keycloakSub"`
	Handle      *string `json:"handle,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
}

func (UserShadow) IsNode() {}

// UserShadowWhereInput is used for filtering UserShadow objects.
// Input was generated by ent.
type UserShadowWhereInput struct {
	Not *UserShadowWhereInput   `json:"not,omitempty"`
	And []*UserShadowWhereInput `json:"and,omitempty"`
	Or  []*UserShadowWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// keycloak_sub field predicates
	KeycloakSub             *string  `json:"keycloakSub,omitempty"`
	KeycloakSubNeq          *string  `json:"keycloakSubNEQ,omitempty"`
	KeycloakSubIn           []string `json:"keycloakSubIn,omitempty"`
	KeycloakSubNotIn        []string `json:"keycloakSubNotIn,omitempty"`
	KeycloakSubGt           *string  `json:"keycloakSubGT,omitempty"`
	KeycloakSubGte          *string  `json:"keycloakSubGTE,omitempty"`
	KeycloakSubLt           *string  `json:"keycloakSubLT,omitempty"`
	KeycloakSubLte          *string  `json:"keycloakSubLTE,omitempty"`
	KeycloakSubContains     *string  `json:"keycloakSubContains,omitempty"`
	KeycloakSubHasPrefix    *string  `json:"keycloakSubHasPrefix,omitempty"`
	KeycloakSubHasSuffix    *string  `json:"keycloakSubHasSuffix,omitempty"`
	KeycloakSubEqualFold    *string  `json:"keycloakSubEqualFold,omitempty"`
	KeycloakSubContainsFold *string  `json:"keycloakSubContainsFold,omitempty"`
	// handle field predicates
	Handle             *string  `json:"handle,omitempty"`
	HandleNeq          *string  `json:"handleNEQ,omitempty"`
	HandleIn           []string `json:"handleIn,omitempty"`
	HandleNotIn        []string `json:"handleNotIn,omitempty"`
	HandleGt           *string  `json:"handleGT,omitempty"`
	HandleGte          *string  `json:"handleGTE,omitempty"`
	HandleLt           *string  `json:"handleLT,omitempty"`
	HandleLte          *string  `json:"handleLTE,omitempty"`
	HandleContains     *string  `json:"handleContains,omitempty"`
	HandleHasPrefix    *string  `json:"handleHasPrefix,omitempty"`
	HandleHasSuffix    *string  `json:"handleHasSuffix,omitempty"`
	HandleIsNil        *bool    `json:"handleIsNil,omitempty"`
	HandleNotNil       *bool    `json:"handleNotNil,omitempty"`
	HandleEqualFold    *string  `json:"handleEqualFold,omitempty"`
	HandleContainsFold *string  `json:"handleContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SearchSort string

const (
	SearchSortRelevance SearchSort = "RELEVANCE"
	SearchSortTitleAsc  SearchSort = "TITLE_ASC"
	SearchSortTitleDesc SearchSort = "TITLE_DESC"
	SearchSortYearAsc   SearchSort = "YEAR_ASC"
	SearchSortYearDesc  SearchSort = "YEAR_DESC"
)

var AllSearchSort = []SearchSort{
	SearchSortRelevance,
	SearchSortTitleAsc,
	SearchSortTitleDesc,
	SearchSortYearAsc,
	SearchSortYearDesc,
}

func (e SearchSort) IsValid() bool {
	switch e {
	case SearchSortRelevance, SearchSortTitleAsc, SearchSortTitleDesc, SearchSortYearAsc, SearchSortYearDesc:
		return true
	}
	return false
}

func (e SearchSort) String() string {
	return string(e)
}

func (e *SearchSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchSort", str)
	}
	return nil
}

func (e SearchSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
